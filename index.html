<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Altagether NC Dashboard Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Alegreya:wght@800&display=swap" rel="stylesheet">
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-kml@1.0.0/dist/leaflet-kml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --dark-green: #283618;
      --medium-green: #606C38;
      --light-cream: #FEFAE0;
      --tan: #DDA15E;
      --brown: #BC6C25;
      --light-green: #afcc8e;
      --lighter-green: #cdf4a0;
      
      /* Semantic color mappings */
      --primary: var(--medium-green);
      --primary-dark: var(--dark-green);
      --accent: var(--tan);
      --accent-dark: var(--brown);
      --background: var(--light-cream);
      --background-light: var(--lighter-green);
      --highlight: var(--light-green);
      --text: var(--dark-green);
      --text-light: rgba(40, 54, 24, 0.7);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--background) 0%, var(--background-light) 100%);
      color: var(--text);
    }

    /* Typography - Alegreya Extra Bold for headings */
    h1, h2, h3, h4, h5, h6,
    .nav-item,
    .header-left,
    .chart-title,
    .card-header,
    .btn-save,
    .btn-load,
    .nav-load-btn {
      font-family: 'Alegreya', serif;
      font-weight: 800;
    }

    /* Top Header Bar */
    .top-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 56px;
      background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary) 100%);
      color: var(--light-cream);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.3), 0 2px 4px rgba(40, 54, 24, 0.2);
      backdrop-filter: blur(10px);
    }

    .header-left {
      font-size: 1.2rem;
      letter-spacing: 0.5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .live-indicator {
      color: var(--lighter-green);
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      padding: 4px 12px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      backdrop-filter: blur(5px);
    }

    #zoneNameDisplay {
      font-weight: 500;
    }

    /* App Container */
    .app-container {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
    }

    /* Left Navigation Bar */
    .left-nav {
      width: 240px;
      background: linear-gradient(180deg, var(--background) 0%, rgba(254, 250, 224, 0.95) 100%);
      border-right: 3px solid var(--primary);
      display: flex;
      flex-direction: column;
      z-index: 100;
      box-shadow: 4px 0 12px rgba(40, 54, 24, 0.15), 2px 0 4px rgba(40, 54, 24, 0.1);
      overflow-y: auto;
      overflow-x: hidden;
      backdrop-filter: blur(10px);
    }

    .nav-section {
      padding: 20px 0;
      border-bottom: 1px solid rgba(96, 108, 56, 0.2);
    }

    .nav-section-bottom {
      margin-top: auto;
      border-top: 3px solid var(--primary);
      border-bottom: none;
      padding: 20px;
      background: rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(5px);
    }

    .nav-item {
      display: block;
      width: 100%;
      padding: 14px 24px;
      background: none;
      border: none;
      text-align: left;
      font-size: 1.05rem;
      color: var(--text);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      letter-spacing: 0.3px;
      position: relative;
      overflow: hidden;
    }

    .nav-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: var(--accent);
      transform: scaleY(0);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .nav-item:hover {
      background: linear-gradient(90deg, rgba(175, 204, 142, 0.2) 0%, rgba(205, 244, 160, 0.1) 100%);
      color: var(--primary-dark);
      transform: translateX(4px);
    }

    .nav-item:hover::before {
      transform: scaleY(1);
    }

    .nav-item.active {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      font-weight: 800;
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .nav-item.active::before {
      background: var(--accent);
      transform: scaleY(1);
      width: 5px;
    }

    .sheet-link-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sheet-link-section label {
      font-size: 0.9rem;
      color: var(--primary-dark);
      margin-bottom: 6px;
      letter-spacing: 0.3px;
    }

    .nav-sheet-input {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid rgba(96, 108, 56, 0.3);
      border-radius: 8px;
      font-size: 0.85rem;
      background: rgba(255, 255, 255, 0.8);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .nav-sheet-input:focus {
      outline: none;
      border-color: var(--primary);
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.2), 0 0 0 3px rgba(96, 108, 56, 0.1);
    }

    .nav-load-btn {
      padding: 10px 20px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 8px rgba(188, 108, 37, 0.3), 0 2px 4px rgba(188, 108, 37, 0.2);
      letter-spacing: 0.5px;
    }

    .nav-load-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(188, 108, 37, 0.4), 0 4px 6px rgba(188, 108, 37, 0.3);
    }

    .nav-load-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(188, 108, 37, 0.3);
    }

    /* Full Screen Map */
    .map-container {
      position: absolute;
      top: 0; /* Will be adjusted dynamically by JavaScript */
      left: 240px;
      right: 420px; /* Leave space for floating panel */
      bottom: 0;
      z-index: 1;
    }

    #zoneMap {
      width: 100%;
      height: 100%;
    }

    .map-toggle-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 12px 16px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(254, 250, 224, 0.95) 100%);
      border: 2px solid var(--primary);
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1rem;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.3), 0 2px 4px rgba(40, 54, 24, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
    }

    .map-toggle-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, var(--light-cream) 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 54, 24, 0.4), 0 4px 6px rgba(40, 54, 24, 0.3);
    }

    /* Persistent Filter Bar */
    .filter-bar {
      position: fixed;
      top: 56px;
      left: 240px;
      right: 420px;
      background: linear-gradient(135deg, rgba(254, 250, 224, 0.98) 0%, rgba(255, 255, 255, 0.98) 100%);
      border-bottom: 2px solid var(--primary);
      z-index: 175;
      padding: 16px 32px;
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
      backdrop-filter: blur(10px);
    }

    .filter-bar-content {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .filter-bar .filters-label {
      font-weight: 800;
      font-size: 1rem;
      color: var(--primary-dark);
      letter-spacing: 0.5px;
      margin-right: 4px;
    }

    .filter-bar select {
      padding: 10px 14px;
      border: 2px solid rgba(96, 108, 56, 0.3);
      border-radius: 8px;
      font-size: 0.9rem;
      background: rgba(255, 255, 255, 0.9);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .filter-bar select:focus {
      outline: none;
      border-color: var(--primary);
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.2), 0 0 0 3px rgba(96, 108, 56, 0.1);
    }

    .filter-bar select.filter-active {
      border-color: var(--accent);
      background: rgba(221, 161, 94, 0.15);
      box-shadow: 0 2px 6px rgba(188, 108, 37, 0.2);
    }

    .filter-bar .contact-filter-group {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-left: 8px;
    }

    .filter-bar .contact-filter-checkbox {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      color: var(--primary-dark);
      user-select: none;
    }

    .filter-bar .contact-filter-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--primary);
    }

    .filter-bar .contact-filter-checkbox span {
      font-weight: 500;
    }

    .details-header {
      font-weight: 800;
      font-size: 1.1rem;
      color: var(--primary-dark);
      letter-spacing: 0.5px;
      padding: 12px 16px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* Floating Right Panel */
    .floating-panel {
      position: fixed;
      top: 56px;
      right: 0;
      width: 420px;
      bottom: 0;
      background: linear-gradient(180deg, var(--background) 0%, rgba(254, 250, 224, 0.98) 100%);
      box-shadow: -4px 0 16px rgba(40, 54, 24, 0.2), -2px 0 8px rgba(40, 54, 24, 0.15);
      z-index: 200;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: blur(10px);
      border-left: 3px solid var(--primary);
    }

    /* Content Views */
    .content-view {
      position: absolute;
      top: 0; /* Will be adjusted dynamically by JavaScript */
      left: 240px;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(254, 250, 224, 0.98) 0%, rgba(255, 255, 255, 0.98) 100%);
      z-index: 150;
      overflow-y: auto;
      padding: 32px;
      backdrop-filter: blur(10px);
    }

    .content-view.active {
      display: block;
    }

    /* Addresses & People view - leave space for floating panel */
    .content-view#peopleView {
      right: 420px; /* Leave space for the floating panel */
      top: 0; /* Will be adjusted dynamically by JavaScript */
    }

    /* Address Table View */
    .address-table-container {
      width: 100%;
      max-height: calc(100vh - 260px); /* Leave space for header, filters, and padding */
      overflow-x: auto;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .address-table {
      width: auto;
      min-width: 100%;
      border-collapse: collapse;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.15), 0 2px 4px rgba(40, 54, 24, 0.1);
      border-radius: 12px;
      overflow: visible;
      backdrop-filter: blur(10px);
    }

    .address-table thead {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .address-table th {
      padding: 16px;
      text-align: left;
      font-weight: 800;
      font-size: 0.95rem;
      letter-spacing: 0.5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .address-table th:nth-child(1),
    .address-table td:nth-child(1) {
      width: auto;
      min-width: 120px; /* Minimum width to prevent it from getting too narrow */
      white-space: nowrap; /* Keep addresses on one line */
    }

    .address-table th:nth-child(2),
    .address-table td:nth-child(2) {
      width: 21%;
      max-width: 175px;
    }

    .address-table td:nth-child(2) {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .address-table td {
      padding: 14px 16px;
      border-bottom: 1px solid rgba(96, 108, 56, 0.15);
      transition: all 0.2s ease;
    }

    .address-table tbody tr {
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .address-table tbody tr:hover {
      background: linear-gradient(90deg, rgba(175, 204, 142, 0.2) 0%, rgba(205, 244, 160, 0.15) 100%);
      box-shadow: inset 4px 0 0 var(--accent);
    }

    .address-table tbody tr.selected {
      background: linear-gradient(90deg, rgba(175, 204, 142, 0.3) 0%, rgba(205, 244, 160, 0.2) 100%);
      box-shadow: inset 4px 0 0 var(--primary);
    }

    .table-filters {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .filters-label {
      font-weight: 800;
      font-size: 1rem;
      color: var(--primary-dark);
      letter-spacing: 0.5px;
      margin-right: 4px;
    }

    .contact-filter-group {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-left: 8px;
    }

    .contact-filter-checkbox {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      color: var(--primary-dark);
      user-select: none;
    }

    .contact-filter-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--primary);
    }

    .contact-filter-checkbox span {
      font-weight: 500;
    }

    .table-filters select {
      padding: 10px 14px;
      border: 2px solid rgba(96, 108, 56, 0.3);
      border-radius: 8px;
      font-size: 0.9rem;
      background: rgba(255, 255, 255, 0.9);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .table-filters select:focus {
      outline: none;
      border-color: var(--primary);
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.2), 0 0 0 3px rgba(96, 108, 56, 0.1);
    }

    .map-kml-input {
      margin: 0 8px 8px 8px;
      padding: 6px 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.85rem;
      width: calc(100% - 32px);
    }

    .map-toggle-btn {
      margin-left: auto;
      padding: 4px 8px;
      background: rgba(255,255,255,0.8);
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }

    .map-toggle-btn:hover {
      background: rgba(255,255,255,1);
    }


    /* Zone Overview panel */
    .zone-progress-panel {
      width: 100%;
      margin-top: 16px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }

    .zone-progress-panel h3 {
      margin: 0 0 24px 0;
      color: var(--primary-dark);
      font-size: 1.4rem;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      letter-spacing: 0.5px;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 28px;
      margin-top: 24px;
    }

    .chart-container {
      position: relative;
      height: 300px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(254, 250, 224, 0.9) 100%);
      border-radius: 12px;
      padding: 20px;
      padding-bottom: 50px;
      box-shadow: 0 4px 12px rgba(40, 54, 24, 0.15), 0 2px 4px rgba(40, 54, 24, 0.1);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(96, 108, 56, 0.2);
      transition: all 0.3s ease;
    }

    .chart-container:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 16px rgba(40, 54, 24, 0.2), 0 4px 6px rgba(40, 54, 24, 0.15);
    }

    .chart-title {
      font-size: 1rem;
      font-weight: 800;
      color: var(--primary-dark);
      margin-bottom: 16px;
      text-align: center;
      letter-spacing: 0.5px;
    }

    .zone-notes-card {
      background: #ffffff;
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.06);
      margin-bottom: 16px;
    }

    .zone-notes-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
    }

    .zone-notes-text {
      width: 100%;
      flex: 1;
      min-height: 300px;
      padding: 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .btn-save-small {
      padding: 8px 16px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border: 0;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 800;
      margin-left: auto;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 6px rgba(188, 108, 37, 0.3);
      letter-spacing: 0.3px;
    }

    .btn-save-small:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(188, 108, 37, 0.4);
    }

    .save-status-small {
      margin-top: 4px;
      font-size: 0.8rem;
      min-height: 16px;
    }

    .save-status-small.saved {
      color: #214025;
    }

    .save-status-small.error {
      color: var(--brown);
      font-weight: 600;
    }

    /* Floating Address Panel */
    .address-panel {
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .address-panel .card-header {
      padding: 0;
      margin: 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .address-panel-tabs {
      display: flex;
      gap: 0;
      margin: 0;
      padding: 0;
      position: relative;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      align-items: stretch;
      border-bottom: 3px solid var(--primary);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.8) 0%, rgba(254, 250, 224, 0.6) 100%);
      flex-shrink: 0;
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(40, 54, 24, 0.1);
      overflow: hidden;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }

    .tab-btn {
      padding: 14px 20px;
      background: transparent;
      border: none;
      border-bottom: 4px solid transparent;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 800;
      color: var(--text-light);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      white-space: nowrap;
      flex-shrink: 1;
      flex-grow: 0;
      letter-spacing: 0.3px;
      min-width: 0;
    }

    .tab-btn:hover {
      color: var(--primary-dark);
      background: linear-gradient(180deg, rgba(175, 204, 142, 0.2) 0%, rgba(205, 244, 160, 0.1) 100%);
    }

    .tab-btn.active {
      color: var(--primary-dark);
      border-bottom-color: var(--accent);
      background: transparent;
      font-weight: 800;
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent) 0%, var(--accent-dark) 100%);
      box-shadow: 0 2px 4px rgba(188, 108, 37, 0.3);
    }

    .btn-contact-mode {
      padding: 8px 12px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(254, 250, 224, 0.95) 100%);
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 800;
      color: var(--primary-dark);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(96, 108, 56, 0.2);
      letter-spacing: 0.3px;
      white-space: nowrap;
      flex-shrink: 0;
      margin: 0;
      box-sizing: border-box;
    }

    .btn-contact-mode:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, var(--light-cream) 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.3);
    }

    .btn-contact-mode.active {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      border-color: var(--primary-dark);
      box-shadow: 0 4px 12px rgba(96, 108, 56, 0.4);
    }

    .contact-mode-indicator {
      display: inline-block;
      padding: 2px 8px;
      background: rgba(255, 200, 0, 0.2);
      border: 1px solid rgba(255, 200, 0, 0.5);
      border-radius: 4px;
      font-size: 0.75rem;
      color: #856404;
      margin-left: 8px;
    }

    .contact-button {
      padding: 6px 12px;
      background: var(--primary);
      border: 1px solid var(--primary-dark);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--light-cream);
      transition: all 0.2s;
      margin-top: 8px;
    }

    .contact-button:hover {
      background: var(--primary-dark);
    }

    .contact-button.contacted {
      background: var(--accent);
      color: var(--light-cream);
      border-color: var(--accent-dark);
    }

    .contact-button.contacted:hover {
      background: var(--accent-dark);
    }

    .contact-date {
      font-size: 0.8rem;
      color: #666;
      margin-top: 4px;
      font-style: italic;
    }

    .contact-notes-quick {
      width: 100%;
      margin-top: 8px;
      padding: 6px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 4px;
      font-size: 0.85rem;
      font-family: inherit;
      resize: vertical;
      min-height: 60px;
    }

    .person-entry.no-contact {
      border-left-color: #ff9800;
      background: rgba(255, 152, 0, 0.05);
    }

    .person-entry.recent-contact {
      border-left-color: #4caf50;
    }

    .zone-notes-content {
      padding: 12px;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .zone-notes-text {
      width: 100%;
      flex: 1;
      min-height: 300px;
      padding: 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .address-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      padding-right: 16px;
    }

    .address-filters {
      margin-bottom: 12px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .address-filters select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      background: white;
      cursor: pointer;
    }

    .address-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .address-item {
      padding: 8px 10px;
      margin-bottom: 6px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .address-item:hover {
      background: rgba(255, 255, 255, 0.9);
      border-color: var(--river);
      transform: translateX(2px);
    }

    .address-item.active {
      background: var(--river);
      color: white;
      border-color: var(--river);
    }

    .address-details {
      display: none;
    }

    .address-details.active {
      display: block;
    }

    .address-details h3 {
      margin: 0 0 12px 0;
      font-size: 1.1rem;
      color: var(--river);
      border-bottom: 2px solid var(--river);
      padding-bottom: 6px;
    }

    .person-entry {
      background: rgba(255, 255, 255, 0.7);
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 6px;
      border-left: 3px solid var(--mint);
    }

    .person-name {
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--plum);
    }

    .person-info {
      font-size: 0.9rem;
      color: #143039;
      margin: 4px 0;
    }

    .person-info strong {
      color: var(--river);
    }

    .loading, .error, .empty {
      padding: 20px;
      text-align: center;
      color: rgba(0, 0, 0, 0.6);
    }

    .error {
      color: var(--brown);
      font-weight: 600;
    }

    .btn-refresh {
      padding: 8px 10px;
      background: linear-gradient(135deg, var(--light-green) 0%, var(--lighter-green) 100%);
      color: var(--primary-dark);
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.1rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(96, 108, 56, 0.2);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      flex-shrink: 0;
      margin: 0;
    }

    .btn-refresh:hover {
      transform: rotate(90deg) translateY(-2px);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.3);
    }

    .btn-refresh.active {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border-color: var(--accent-dark);
    }

    .btn-back {
      padding: 10px 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: var(--light-cream);
      border: 0;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 800;
      margin: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 8px rgba(40, 54, 24, 0.3);
      letter-spacing: 0.3px;
      align-self: center;
    }

    .btn-back:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(40, 54, 24, 0.4);
    }

    .btn-signin {
      padding: 12px 24px;
      background: linear-gradient(135deg, #4285f4 0%, #357ae8 100%);
      color: white;
      border: 0;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 800;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      margin: 12px 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4);
      letter-spacing: 0.3px;
    }

    .btn-signin:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(66, 133, 244, 0.5);
    }

    .btn-save {
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: var(--light-cream);
      border: 0;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 800;
      margin-top: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(188, 108, 37, 0.4);
      letter-spacing: 0.3px;
    }

    .btn-save-small {
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 800;
      letter-spacing: 0.3px;
      margin-top: 0;
    }

    .btn-refresh-small {
      padding: 8px 10px;
      background: linear-gradient(135deg, var(--light-green) 0%, var(--lighter-green) 100%);
      color: var(--primary-dark);
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(96, 108, 56, 0.2);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      flex-shrink: 0;
    }

    .btn-refresh-small:hover {
      transform: rotate(90deg) translateY(-2px);
      box-shadow: 0 4px 8px rgba(96, 108, 56, 0.3);
    }

    .btn-save:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(188, 108, 37, 0.5);
    }

    .btn-save:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .signin-prompt {
      background: rgba(255, 255, 255, 0.8);
      padding: 16px;
      border-radius: 8px;
      text-align: center;
      margin: 10px 0;
      border: 2px dashed var(--river);
    }

    .signin-prompt p {
      margin: 0 0 12px 0;
      color: #143039;
      font-size: 0.9rem;
    }

    .editable-field {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--mint);
      border-radius: 4px;
      padding: 6px 8px;
      min-height: 20px;
      cursor: text;
      transition: all 0.2s;
    }

    .editable-field:focus {
      outline: none;
      border-color: var(--river);
      background: white;
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.2);
    }

    .editable-field:empty:before {
      content: "Click to add notes...";
      color: rgba(0, 0, 0, 0.4);
    }

    /* Expandable notes textarea */
    .editable-notes {
      width: 100%;
      background: #ffffff;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      padding: 8px;
      min-height: 60px;
      font-family: inherit;
      font-size: 0.9rem;
      resize: vertical;
      cursor: text;
      transition: all 0.2s;
      box-sizing: border-box;
    }

    .editable-notes:focus {
      outline: none;
      border-color: var(--river);
      box-shadow: 0 0 0 2px rgba(33, 64, 37, 0.1);
    }

    .editable-notes::placeholder {
      color: rgba(0, 0, 0, 0.4);
    }

    /* Subtle editable field for non-notes */
    .editable-inline {
      display: inline-block;
      background: rgba(255, 255, 255, 0.4);
      border: 1px dashed rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      padding: 2px 6px;
      min-width: 60px;
      cursor: text;
      transition: all 0.2s;
    }

    .editable-inline:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: var(--mint);
    }

    .editable-inline:focus {
      outline: none;
      background: white;
      border: 1px solid var(--river);
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .editable-inline:empty:before {
      content: "...";
      color: rgba(0, 0, 0, 0.3);
    }

    /* Custom marker styling */
    .custom-marker {
      background: transparent !important;
      border: none !important;
    }

    /* Dropdown for Damage and Household Status */
    .editable-dropdown {
      display: inline-block;
      background: rgba(255, 255, 255, 0.4);
      border: 1px dashed rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      padding: 2px 6px;
      min-width: 100px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: inherit;
      font-family: inherit;
      color: inherit;
    }

    .editable-dropdown:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: var(--mint);
    }

    .editable-dropdown:focus {
      outline: none;
      background: white;
      border: 1px solid var(--river);
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .save-status {
      font-size: 0.8rem;
      margin-top: 6px;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
    }

    .save-status.saving {
      background: var(--sunbeam);
      color: #143039;
    }

    .save-status.saved {
      background: var(--mint);
      color: #214025;
    }

    .save-status.error {
      background: var(--clementine);
      color: white;
    }

    .save-status-top {
      font-size: 0.65rem;
      margin-top: 0;
      padding: 2px 6px;
      height: 18px;
      line-height: 1.2;
      text-align: right;
      display: block;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .bottom-row {
      display: flex;
      gap: 16px;
    }

    .bottom-card { flex: 1; }
    .bottom-card:nth-child(1) { background: var(--honey); }
    .bottom-card:nth-child(2) { background: var(--sunbeam); }
    .bottom-card:nth-child(3) { background: var(--mint); }

    .link-list {
      margin: 6px 0 0;
      padding-left: 0;
      list-style: none;
      font-size: 0.9rem;
    }

    .link-list li { margin-bottom: 4px; }
    .link-list a { color: var(--river); text-decoration: none; }

    @media (max-width: 900px) {
      .main { flex-direction: column; }
      .bottom-row { flex-direction: column; }
    }
  </style>
</head>

<body>
  <!-- Top Header Bar -->
  <div class="top-header">
    <div class="header-left" id="headerLeft">Zone XX â€¢ Altagether Dashboard</div>
    <div class="header-right">
      <span class="live-indicator">Live updates</span>
    </div>
    </div>

    <!-- Persistent Filter Bar -->
    <div class="filter-bar" id="filterBar" style="display: none;">
      <div class="filter-bar-content" id="filterBarContent">
        <!-- Filters will be inserted here -->
      </div>
    </div>

    <!-- App Container -->
    <div class="app-container">
    <!-- Left Navigation Bar -->
    <nav class="left-nav">
      <div class="nav-section">
        <button class="nav-item" data-view="map" id="navMap">Map</button>
        <button class="nav-item active" data-view="people" id="navPeople">Addresses & People</button>
        <button class="nav-item" data-view="progress" id="navProgress">Zone Overview</button>
        <button class="nav-item" data-view="tools" id="navTools">Tools</button>
        <button class="nav-item" data-view="meetups" id="navMeetups">Meetups</button>
        <button class="nav-item" data-view="help" id="navHelp">Help</button>
      </div>
      <div class="nav-section nav-section-bottom">
        <div class="sheet-link-section">
          <label>Link your zone spreadsheet</label>
          <input id="sheetUrlInput" class="nav-sheet-input" placeholder="Paste Google Sheet URL" />
          <button class="nav-load-btn" id="loadSheetBtn">Load</button>
        </div>
      </div>
    </nav>

    <!-- Full Screen Map -->
    <div class="map-container">
      <div id="zoneMap"></div>
    </div>

    <!-- Floating Right Panel (Addresses/Zone Notes/Contact Mode) -->
    <div class="floating-panel" id="floatingPanel">
      <div class="address-panel">
        <div class="address-panel-tabs">
          <div class="details-header">Details</div>
          <button class="tab-btn" id="zoneNotesTab" data-tab="notes" style="display: none;">Zone Notes</button>
          <div style="margin-left: auto; padding: 8px 8px; display: flex; gap: 0; align-items: center; flex-shrink: 0; min-width: 0;">
            <button class="btn-contact-mode" id="contactModeBtn" title="Toggle contact tracking mode">ðŸ“ž Contact Mode</button>
          </div>
        </div>
        <div class="address-panel-content" id="addressPanelContent">
          <div class="empty">Load a spreadsheet to see addresses</div>
        </div>
        <div class="zone-notes-content" id="zoneNotesContent" style="display: none;">
          <textarea id="zoneNotesText" class="zone-notes-text" placeholder="Zone-level notes appear here..."></textarea>
          <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center;">
            <div class="save-status-small" id="zoneNotesStatus"></div>
            <button class="btn-save-small" id="saveZoneNotesBtn" title="Save notes">ðŸ’¾ Save</button>
          </div>
        </div>
        <div id="signinPrompt" style="display: none;" class="signin-prompt">
          <p><strong>Sign in to edit</strong><br>Click below to sign in with Google and enable editing</p>
          <button class="btn-signin" id="signInBtn">
            <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
            Sign in with Google
          </button>
        </div>
      </div>
    </div>

    <!-- Content Views -->
    <!-- Map View (just shows map, no overlay) -->
    <div class="content-view" id="mapView" style="display: none;">
      <!-- Map view doesn't need content - map is always visible in background -->
    </div>

    <!-- Addresses & People View (Table) -->
    <div class="content-view" id="peopleView" style="display: none;">
      <div id="peopleTableView"></div>
    </div>

    <!-- Tools View -->
    <div class="content-view" id="toolsView" style="display: none;">
      <h2 style="margin-top: 0; color: var(--primary-dark); font-size: 2rem; letter-spacing: 0.5px; text-shadow: 0 2px 4px rgba(40, 54, 24, 0.1);">Tools</h2>
      <p>Tools menu coming soon...</p>
    </div>

    <!-- Meetups View -->
    <div class="content-view" id="meetupsView" style="display: none;">
      <h2 style="margin-top: 0; color: var(--primary-dark); font-size: 2rem; letter-spacing: 0.5px; text-shadow: 0 2px 4px rgba(40, 54, 24, 0.1);">Meetups</h2>
      <p>Meetups feature coming soon...</p>
    </div>

    <!-- Zone Overview View -->
    <div class="content-view" id="progressView" style="display: none;">
      <h2 style="margin-top: 0; color: var(--primary-dark); font-size: 2rem; letter-spacing: 0.5px; text-shadow: 0 2px 4px rgba(40, 54, 24, 0.1);">Zone Overview</h2>
      <div class="charts-grid" id="chartsGrid">
        <div class="chart-container">
          <div class="chart-title">People Contacted</div>
          <canvas id="peopleContactChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">Households Contacted</div>
          <canvas id="householdsContactChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">Damage Status</div>
          <canvas id="damageChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">Household Status</div>
          <canvas id="householdStatusChart"></canvas>
        </div>
      </div>
    </div>

    <!-- Help View -->
    <div class="content-view" id="helpView" style="display: none;">
      <h2 style="margin-top: 0; color: var(--primary-dark); font-size: 2rem; letter-spacing: 0.5px; text-shadow: 0 2px 4px rgba(40, 54, 24, 0.1);">Help</h2>
      <p>Help documentation coming soon...</p>
    </div>
  </div>

  <script>
    const input = document.getElementById("sheetUrlInput");
    const btn = document.getElementById("loadSheetBtn");
    // Refresh button removed - data auto-loads after sign-in
    const addressPanelContent = document.getElementById("addressPanelContent");
    const signInBtn = document.getElementById("signInBtn");
    const signinPrompt = document.getElementById("signinPrompt");

    // Navigation state
    let currentView = 'people'; // Default view
    let currentSheetUrl = '';
    let sheetData = [];
    let selectedAddress = null; // Track currently selected address
    let savedScrollPosition = 0; // Track scroll position for refresh
    let accessToken = null; // OAuth2 access token
    let currentSheetId = null; // Current sheet ID for writing
    let currentStreetFilter = 'all'; // Current street filter
    let currentDamageFilter = 'all'; // Current damage filter
    let currentStatusFilter = 'all'; // Current household status filter
    let currentRebuildFilter = 'all'; // Current rebuild status filter
    let showContactedAddresses = true; // Show addresses with contacted people
    let showUncontactedAddresses = true; // Show addresses with uncontacted people
    let tableSortColumn = null; // Current sort column
    let tableSortDirection = 'asc'; // Sort direction: 'asc' or 'desc'
    let zoneMap = null; // Leaflet map instance
    let addressMarkers = []; // Array of address markers
    let kmlLayer = null; // KML boundary layer
    let currentTileLayer = null; // Current map tile layer
    let isSatelliteMode = false; // Track satellite mode state
    let zoneNotes = ''; // Zone-level notes
    let zoneKmlUrl = ''; // Zone KML URL from metadata
    let metadataSheetId = null; // Sheet ID for metadata sheet
    let autoSaveTimer = null; // Timer for debounced auto-save

    // Load OAuth token from localStorage
    const savedToken = localStorage.getItem('googleOAuthToken');
    const savedTokenExpiry = localStorage.getItem('googleOAuthTokenExpiry');
    if (savedToken && savedTokenExpiry && Date.now() < parseInt(savedTokenExpiry)) {
      accessToken = savedToken;
      updateSignInUI();
    }

    // Load saved sheet URL from localStorage
    const savedSheetUrl = localStorage.getItem('savedSheetUrl');
    if (savedSheetUrl && input) {
      input.value = savedSheetUrl;
      currentSheetUrl = savedSheetUrl;
      // Auto-load the sheet if user is signed in (wait a bit for OAuth to initialize)
      if (accessToken) {
        setTimeout(() => {
          if (currentSheetUrl) {
            loadAddressData(currentSheetUrl);
          }
        }, 1000);
      }
    }

    // Initialize Google API
    function initGoogleAPI() {
      gapi.load('client', () => {
        gapi.client.init({
          apiKey: savedApiKey || '',
          discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
        }).then(() => {
          console.log('Google API initialized');
        });
      });
    }

    // Initialize on page load
    if (typeof gapi !== 'undefined') {
      initGoogleAPI();
    } else {
      window.addEventListener('load', () => {
        if (typeof gapi !== 'undefined') {
          initGoogleAPI();
        }
      });
    }

    // ============================================
    // CONFIGURATION: OAuth Client ID
    // ============================================
    // To enable editing, you need a Google OAuth Client ID:
    // 1. Go to https://console.cloud.google.com/apis/credentials
    // 2. Create OAuth 2.0 Client ID (Web application)
    // 3. Add your domain to authorized JavaScript origins
    // 4. Replace 'YOUR_CLIENT_ID' below with your actual Client ID
    // ============================================
    const OAUTH_CLIENT_ID = '633926045450-3214il5eg7emu5e0fp8am1g26jdfnoh7.apps.googleusercontent.com'; // Replace with your OAuth Client ID

    // OAuth2 Sign In
    async function signIn() {
      if (OAUTH_CLIENT_ID === 'YOUR_CLIENT_ID') {
        alert('OAuth Client ID not configured. Please set OAUTH_CLIENT_ID in the code.');
        return;
      }
      
      try {
        const tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: OAUTH_CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/spreadsheets',
          callback: (response) => {
            if (response.error) {
              console.error('Sign in error:', response.error);
              alert('Sign in failed. Please try again.');
              return;
            }
            accessToken = response.access_token;
            // Store token with expiry (tokens last 1 hour, store for 50 minutes)
            const expiry = Date.now() + (50 * 60 * 1000);
            localStorage.setItem('googleOAuthToken', accessToken);
            localStorage.setItem('googleOAuthTokenExpiry', expiry.toString());
            updateSignInUI();
            
            // Auto-load data after sign-in if we have a sheet URL
            const savedSheetUrl = localStorage.getItem('savedSheetUrl');
            const sheetUrlToLoad = currentSheetUrl || savedSheetUrl;
            
            if (sheetUrlToLoad) {
              currentSheetUrl = sheetUrlToLoad;
              // Small delay to ensure UI updates
              setTimeout(() => {
                loadAddressData(sheetUrlToLoad);
              }, 500);
            } else if (selectedAddress && currentSheetUrl) {
              // Fallback: refresh current address if one is selected
              loadAddressData(currentSheetUrl);
            }
          },
        });
        tokenClient.requestAccessToken({ prompt: 'consent' });
      } catch (error) {
        console.error('Sign in error:', error);
        alert('Error signing in. Please try again.');
      }
    }

    // Sign Out
    function signOut() {
      accessToken = null;
      localStorage.removeItem('googleOAuthToken');
      localStorage.removeItem('googleOAuthTokenExpiry');
      updateSignInUI();
      if (selectedAddress && currentSheetUrl) {
        loadAddressData(currentSheetUrl);
      }
    }

    // Update sign-in UI
    function updateSignInUI() {
      if (accessToken) {
        signinPrompt.style.display = 'none';
        // Could add a sign-out button here if needed
      } else {
        // Always show sign-in prompt when not signed in
        signinPrompt.style.display = 'block';
      }
    }

    // Sign in button handler
    signInBtn.addEventListener('click', signIn);

    // Extract sheet ID from any Google Sheets URL format
    function extractSheetId(sheetUrl) {
      // Handle published format: /spreadsheets/d/e/...
      const publishedMatch = sheetUrl.match(/\/spreadsheets\/d\/e\/([a-zA-Z0-9-_]+)/);
      if (publishedMatch) {
        return { sheetId: publishedMatch[1], isPublished: true };
      }
      
      // Handle standard format: /spreadsheets/d/...
      const standardMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
      if (!standardMatch) {
        return null;
      }
      
      return { sheetId: standardMatch[1], isPublished: false };
    }

    // Convert Google Sheets URL to CSV export URL
    function getCsvUrl(sheetUrl) {
      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        console.error('Could not parse Google Sheets URL:', sheetUrl);
        return null;
      }
      
      if (sheetInfo.isPublished) {
        // For published sheets, use /pub?output=csv
        const csvUrl = `https://docs.google.com/spreadsheets/d/e/${sheetInfo.sheetId}/pub?output=csv`;
        console.log('Converted published URL to CSV:', csvUrl);
        return csvUrl;
      }
      
      // For standard format, extract GID if present
      const gidMatch = sheetUrl.match(/[#&]gid=(\d+)/);
      const gid = gidMatch ? gidMatch[1] : '0';
      
      // Build CSV export URL
      const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetInfo.sheetId}/export?format=csv&gid=${gid}`;
      console.log('Converted standard URL to CSV:', csvUrl);
      return csvUrl;
    }

    // Fetch data using Google Sheets API v4 with OAuth token
    async function fetchViaOAuth(sheetId, range = 'A1:ZZ1000', sheetName = null) {
      // Check if token is expired and refresh if needed
      const storedExpiry = localStorage.getItem('googleOAuthTokenExpiry');
      if (storedExpiry && Date.now() > parseInt(storedExpiry)) {
        console.log('Token expired, clearing...');
        accessToken = null;
        localStorage.removeItem('googleOAuthToken');
        localStorage.removeItem('googleOAuthTokenExpiry');
        throw new Error('Your session has expired. Please sign in again.');
      }
      
      if (!accessToken) {
        throw new Error('Not signed in. Please sign in to view data.');
      }
      
      // If sheetName is provided, use it; otherwise use default range
      const rangeParam = sheetName ? `${sheetName}!${range}` : range;
      const apiUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${rangeParam}`;
      
      const response = await fetch(apiUrl, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });
      
      if (!response.ok) {
        const error = await response.json();
        // If 401, token is invalid - clear it
        if (response.status === 401) {
          accessToken = null;
          localStorage.removeItem('googleOAuthToken');
          localStorage.removeItem('googleOAuthTokenExpiry');
          throw new Error('Your session has expired. Please sign in again.');
        }
        throw new Error(error.error?.message || `API Error: ${response.status}`);
      }
      
      const data = await response.json();
      return data.values || [];
    }

    // Fetch Zone Notes sheet (Zone Notes and KML URL)
    async function fetchMetadata(sheetId) {
      if (!accessToken) {
        console.log('No access token for metadata fetch');
        return null;
      }
      
      try {
        // Try to fetch from "Zone Notes" sheet
        console.log('Attempting to fetch Zone Notes sheet...');
        const metadataValues = await fetchViaOAuth(sheetId, 'A1:B10', 'Zone Notes');
        console.log('Metadata values received:', metadataValues);
        
        if (!metadataValues || metadataValues.length === 0) {
          console.log('Zone Notes sheet is empty or not found');
          return null;
        }
        
        let notes = '';
        let kmlUrl = '';
        
        // Parse metadata - look for "Zone Notes" and "KML URL" rows
        for (let i = 0; i < metadataValues.length; i++) {
          const row = metadataValues[i];
          if (row && row.length >= 2) {
            const key = (row[0] || '').toString().trim().toLowerCase();
            const value = (row[1] || '').toString().trim();
            
            console.log(`Metadata row ${i}: key="${key}", value="${value}"`);
            
            if (key.includes('zone note') || key === 'notes') {
              notes = value;
              console.log('Found Zone Notes:', notes);
            } else if (key.includes('kml') || key.includes('boundary')) {
              // Clean the URL - remove quotes, trim whitespace
              kmlUrl = value.replace(/^["']|["']$/g, '').trim();
              console.log('Found KML URL:', kmlUrl);
            }
          }
        }
        
        return { notes, kmlUrl };
      } catch (error) {
        console.error('Error fetching Zone Notes sheet:', error);
        console.log('Zone Notes sheet not found or error reading it:', error.message);
        return null;
      }
    }

    // Parse CSV text to array of objects
    function parseCSV(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];

      // Parse header
      const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // Parse data rows
      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
        if (values.length === 0 || values.every(v => !v)) continue;
        
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        data.push(row);
      }
      
      return { headers, data };
    }

    // Convert API response (array of arrays) to object format
    function parseApiData(apiValues) {
      if (!apiValues || apiValues.length === 0) return { headers: [], data: [] };
      
      const headers = apiValues[0].map(h => h.trim());
      const data = [];
      
      for (let i = 1; i < apiValues.length; i++) {
        const row = {};
        headers.forEach((header, index) => {
          row[header] = apiValues[i][index] || '';
        });
        // Only add row if it has at least one non-empty value
        if (Object.values(row).some(v => v.trim())) {
          data.push(row);
        }
      }
      
      return { headers, data };
    }

    // Fetch and process spreadsheet data
    async function loadAddressData(sheetUrl) {
      // Save current scroll position before refreshing (if we're refreshing, not initial load)
      if (sheetData.addressMap) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      if (!addressPanelContent) {
        console.error('addressPanelContent element not found');
        return;
      }

      addressPanelContent.innerHTML = '<div class="loading">Loading addresses...</div>';

      // Require OAuth sign-in to read data
      if (!accessToken) {
        addressPanelContent.innerHTML = '<div class="error">Please sign in with Google to view data.</div>';
        // Show sign-in prompt
        if (signinPrompt) signinPrompt.style.display = 'block';
        return;
      }

      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        addressPanelContent.innerHTML = '<div class="error">Invalid Google Sheets URL</div>';
        return;
      }
      
      try {
        let headers, data;
        
        // Use OAuth to fetch data
        console.log('Fetching data via OAuth...');
        try {
          const apiValues = await fetchViaOAuth(sheetInfo.sheetId);
          const parsed = parseApiData(apiValues);
          headers = parsed.headers;
          data = parsed.data;
          console.log('Successfully loaded via OAuth');
          
          // Also fetch Zone Notes sheet
          metadataSheetId = sheetInfo.sheetId;
          console.log('Fetching Zone Notes sheet...');
          const metadata = await fetchMetadata(sheetInfo.sheetId);
          if (metadata) {
            console.log('Metadata found:', metadata);
            zoneNotes = metadata.notes || '';
            zoneKmlUrl = metadata.kmlUrl || '';
            updateZoneNotesUI();
            // Auto-load KML if URL is provided (wait for map to initialize if needed)
            if (zoneKmlUrl) {
              console.log('Auto-loading KML from Zone Notes sheet:', zoneKmlUrl);
              if (zoneMap) {
                loadKMLBoundary(zoneKmlUrl);
              } else {
                // Wait a bit for map to initialize, then load KML
                setTimeout(() => {
                  if (zoneMap && zoneKmlUrl) {
                    console.log('Loading KML after map initialization:', zoneKmlUrl);
                    loadKMLBoundary(zoneKmlUrl);
                  }
                }, 1000);
              }
            } else {
              console.log('No KML URL found in Zone Notes sheet');
            }
          } else {
            console.log('No metadata found or Zone Notes sheet does not exist');
          }
        } catch (oauthError) {
          console.error('OAuth fetch failed:', oauthError);
          throw new Error(`Error loading data: ${oauthError.message}. Make sure you're signed in and have access to this sheet.`);
        }
        
        // No fallback - OAuth is required
        if (!headers || !data) {
          // Fall back to CSV export (requires published sheet)
          const csvUrl = getCsvUrl(sheetUrl);
          if (!csvUrl) {
            throw new Error('Could not generate CSV URL');
          }

          // Try direct fetch first, then CORS proxy if needed
          let csvText;
          try {
            const response = await fetch(csvUrl);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            csvText = await response.text();
          } catch (error) {
            // If direct fetch fails, try CORS proxy
            console.log('Direct fetch failed, trying CORS proxy...', error);
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`;
            const proxyResponse = await fetch(proxyUrl);
            if (!proxyResponse.ok) {
              throw new Error(`Proxy fetch failed: ${proxyResponse.status}. Please sign in with Google.`);
            }
            csvText = await proxyResponse.text();
          }
          
          if (!csvText || csvText.trim().length === 0) {
            throw new Error('Spreadsheet appears to be empty or could not be accessed.');
          }
          
          const parsed = parseCSV(csvText);
          headers = parsed.headers;
          data = parsed.data;
        }
        
        if (data.length === 0) {
          addressPanelContent.innerHTML = '<div class="empty">No data found in spreadsheet</div>';
          return;
        }

        // Find address columns - prefer separate House # and Street, fallback to Address
        const houseNumCol = headers.find(h => {
          const lower = h.toLowerCase();
          // Match "House #" exactly (case-insensitive) or variations
          return h === 'House #' || 
                 lower === 'house #' ||
                 lower.includes('house #') || 
                 lower.includes('house#') ||
                 lower === 'house number' ||
                 lower === 'house num' ||
                 (lower === 'house' && !lower.includes('hold')); // "house" but not "household"
        });
        const streetCol = headers.find(h => {
          const lower = h.toLowerCase();
          // Match "Street" exactly (case-insensitive) or variations
          return h === 'Street' ||
                 lower === 'street' ||
                 (lower.includes('street') && !lower.includes('address'));
        });
        const addressCol = headers.find(h => {
          const lower = h.toLowerCase();
          return (lower.includes('address') || lower.includes('location')) &&
                 !lower.includes('email') && !lower.includes('phone');
        });

        // Helper function to get address string
        const getAddressString = (row) => {
          if (houseNumCol && streetCol) {
            const houseNum = (row[houseNumCol] || '').trim();
            const street = (row[streetCol] || '').trim();
            if (houseNum && street) {
              return `${houseNum} ${street}`;
            } else if (street) {
              return street;
            } else if (houseNum) {
              return houseNum;
            }
          }
          // Fallback to Address column if it exists
          if (addressCol) {
            return (row[addressCol] || '').trim();
          }
          return null;
        };

        // Check if we have at least one way to identify addresses
        if (!houseNumCol && !streetCol && !addressCol) {
          const availableCols = headers.slice(0, 10).join(', ');
          addressPanelContent.innerHTML = `<div class="error">No address columns found. Need either "House #" and "Street" columns, or an "Address" column. Available columns: ${availableCols || 'none'}</div>`;
          return;
        }

        // Group data by address, storing original row index with each row
        const addressMap = new Map();
        data.forEach((row, rowIndex) => {
          const address = getAddressString(row);
          if (!address) return;
          
          if (!addressMap.has(address)) {
            addressMap.set(address, []);
          }
          // Store row with its original index
          addressMap.get(address).push({ ...row, __originalIndex: rowIndex });
        });

        // Store data globally
        sheetData = { headers, data, addressMap, addressCol, houseNumCol, streetCol, getAddressString };
        
        // Update header with Zone information
        const zoneCol = headers.find(h => h.toLowerCase().includes('zone'));
        // Store sheet ID for writing (sheetInfo already defined above)
        if (sheetInfo) {
          currentSheetId = sheetInfo.sheetId;
        }
        
        // Update sign-in UI
        updateSignInUI();
        
        // Reset filters when loading new data
        currentStreetFilter = 'all';
        currentDamageFilter = 'all';
        currentStatusFilter = 'all';
        
        // Extract zone name from ZoneName column if available
        const zoneNameCol = headers.find(h => h.toLowerCase() === 'zonename' || h.toLowerCase() === 'zone name');
        const headerLeft = document.getElementById('headerLeft');
        if (zoneNameCol && data.length > 0 && data[0][zoneNameCol]) {
          const zoneName = data[0][zoneNameCol].trim();
          if (zoneName && headerLeft) {
            headerLeft.textContent = `${zoneName} â€¢ Altagether Dashboard`;
          }
        } else {
          if (headerLeft) {
            headerLeft.textContent = 'Zone XX â€¢ Altagether Dashboard';
          }
        }
        
        // If an address was selected, restore that view; otherwise show list
        if (selectedAddress && addressMap.has(selectedAddress)) {
          displayAddressDetails(selectedAddress, true); // true = preserve scroll
        } else {
          displayAddressList(Array.from(addressMap.keys()).sort());
          // Restore scroll position for list view
          setTimeout(() => {
            addressPanelContent.scrollTop = savedScrollPosition;
          }, 0);
        }
        
        // Populate persistent filter bar
        populateFilterBar();
        
        // Update table view if in people view
        if (currentView === 'people') {
          displayAddressTable();
        }
        
        // Update zone progress charts
        updateZoneProgressCharts();
        
        // Initialize or update map with addresses
        initializeMap();
        updateMapMarkers();
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        const errorMsg = error.message || 'Unknown error';
        
        // Hide zone progress panel on error
        const panel = document.getElementById('zoneProgressPanel');
        if (panel) panel.style.display = 'none';
        
        let helpText = '';
        if (errorMsg.includes('permission') || errorMsg.includes('does not have permission') || errorMsg.includes('sign in')) {
          helpText = `<br><br><strong>Solution:</strong><br>
            1. Click "Sign in with Google" above<br>
            2. Grant permission to access Google Sheets<br>
            3. Make sure you have access to the sheet (it should be shared with you or set to "Anyone with the link can edit")<br>
            4. Refresh and try again`;
        } else {
          helpText = `<br><br>Tips:<br>â€¢ Sign in with Google to view and edit data<br>â€¢ Make sure the sheet is shared with you or set to "Anyone with the link can edit"<br>â€¢ Make sure the sheet has an "Address" column`;
        }
        
        addressPanelContent.innerHTML = `<div class="error">Error loading spreadsheet: ${errorMsg}${helpText}</div>`;
      }
    }

    // Normalize street name by removing unit numbers, suffixes, and other variations
    function normalizeStreet(street) {
      if (!street) return '';
      
      let normalized = street.trim();
      
      // Remove common unit indicators and everything after them
      // Patterns like: "Madison Ave Unit", "Madison Ave Apt B", "Madison Ave #2", etc.
      const unitPatterns = [
        /\s+(Unit|Apt|Apartment|Suite|Ste|#|No\.|Number)\s+.*$/i,
        /\s+(Unit|Apt|Apartment|Suite|Ste)\s*$/i,
        /\s+#\s*\d+.*$/i,
        /\s+\d+[A-Z]?\s*$/, // Trailing numbers/letters like "123" or "B"
      ];
      
      for (const pattern of unitPatterns) {
        normalized = normalized.replace(pattern, '');
      }
      
      // Remove common directional/location suffixes
      // Patterns like: "Madison Ave Rear", "Maple Street Front", etc.
      const suffixPatterns = [
        /\s+(Rear|Front|Back|Side|North|South|East|West|N|S|E|W)\s*$/i,
        /\s+[A-Z]\s*$/, // Single letter suffix like "B" or "A"
      ];
      
      for (const pattern of suffixPatterns) {
        normalized = normalized.replace(pattern, '');
      }
      
      // Clean up extra whitespace
      normalized = normalized.trim();
      
      return normalized;
    }

    // Extract street name from full address
    function extractStreet(address) {
      let street = '';
      
      // Use Street column if available (preferred method)
      if (sheetData && sheetData.streetCol && sheetData.addressMap && sheetData.addressMap.has(address)) {
        const rows = sheetData.addressMap.get(address);
        if (rows && rows.length > 0 && rows[0][sheetData.streetCol]) {
          street = rows[0][sheetData.streetCol].trim();
        }
      }
      
      // Fallback: try to extract from address string (e.g., "2054 MADISON AVE" -> "MADISON AVE")
      if (!street) {
        const parts = address.split(/\s+/);
        if (parts.length > 1) {
          street = parts.slice(1).join(' '); // Everything after the first part (house number)
        } else {
          street = address;
        }
      }
      
      // Normalize the street name to handle units, suffixes, etc.
      return normalizeStreet(street);
    }

    // Get unique streets from all addresses
    function getUniqueStreets(addresses) {
      const streets = new Set();
      addresses.forEach(addr => {
        const street = extractStreet(addr);
        if (street) streets.add(street);
      });
      return Array.from(streets).sort();
    }

    // Get unique damage values from all addresses
    function getUniqueDamage(addresses) {
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      if (!damageCol) return [];
      
      const damages = new Set();
      // Check all data, not just filtered addresses
      sheetData.data.forEach(row => {
        if (row[damageCol] !== undefined && row[damageCol] !== null) {
          const damage = String(row[damageCol]).trim();
          if (damage) damages.add(damage);
        }
      });
      
      // Always include default values (even if not in data yet)
      const defaultDamageValues = ['Total Loss', 'Partial Loss', 'Standing'];
      defaultDamageValues.forEach(val => {
        // Check if this value exists (case-insensitive)
        const existing = Array.from(damages).find(d => d.toLowerCase() === val.toLowerCase());
        if (existing && existing !== val) {
          // Replace with exact case from defaults
          damages.delete(existing);
        }
        damages.add(val);
      });
      
      return Array.from(damages).sort();
    }

    // Get unique household status values from all addresses
    function getUniqueStatus(addresses) {
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (!statusCol) return [];
      
      const statuses = new Set();
      // Check all data, not just filtered addresses
      sheetData.data.forEach(row => {
        if (row[statusCol] !== undefined && row[statusCol] !== null) {
          const status = String(row[statusCol]).trim();
          if (status) statuses.add(status);
        }
      });
      
      // Always include default values (even if not in data yet)
      const defaultStatusValues = ['Planning to Rebuild', 'Selling', 'Renter/Moved', 'Staying'];
      defaultStatusValues.forEach(val => {
        // Check if this value exists (case-insensitive)
        const existing = Array.from(statuses).find(s => s.toLowerCase() === val.toLowerCase());
        if (existing && existing !== val) {
          // Replace with exact case from defaults
          statuses.delete(existing);
        }
        statuses.add(val);
      });
      
      return Array.from(statuses).sort();
    }

    // Check if an address has any contacted people
    function isAddressContacted(address) {
      const contactDateCol = sheetData.headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      if (!contactDateCol) return false;
      
      const rows = sheetData.addressMap.get(address);
      if (!rows || rows.length === 0) return false;
      
      // Check if any person at this address has a contact date
      return rows.some(row => {
        const contactDate = row[contactDateCol];
        return contactDate !== undefined && contactDate !== null && String(contactDate).trim() !== '';
      });
    }

    // Get damage value for an address
    function getAddressDamage(address) {
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      if (!damageCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][damageCol]?.trim() || null;
      }
      return null;
    }

    // Get household status value for an address
    function getAddressStatus(address) {
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (!statusCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][statusCol]?.trim() || null;
      }
      return null;
    }

    // Display list of addresses
    // Populate persistent filter bar
    function populateFilterBar() {
      if (!sheetData || !sheetData.addressMap) {
        const filterBar = document.getElementById('filterBar');
        if (filterBar) filterBar.style.display = 'none';
        return;
      }

      const filterBar = document.getElementById('filterBar');
      const filterBarContent = document.getElementById('filterBarContent');
      if (!filterBar || !filterBarContent) return;

      const addresses = Array.from(sheetData.addressMap.keys());
      const headers = sheetData.headers;
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));

      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      const statuses = getUniqueStatus(addresses);

      // Get unique rebuild status values
      const rebuildStatuses = new Set();
      if (rebuildCol) {
        sheetData.data.forEach(row => {
          if (row[rebuildCol] !== undefined && row[rebuildCol] !== null) {
            const value = String(row[rebuildCol]).trim();
            if (value) rebuildStatuses.add(value);
          }
        });
      }
      const rebuildStatusesArray = Array.from(rebuildStatuses).sort();

      const html = `
        <span class="filters-label">Filters:</span>
        <select id="persistentStreetFilter" class="${currentStreetFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentStreetFilter === 'all' ? 'selected' : ''}>All Streets</option>
          ${streets.map(street => `<option value="${street.replace(/"/g, '&quot;')}" ${currentStreetFilter === street ? 'selected' : ''}>${street}</option>`).join('')}
        </select>
        <select id="persistentDamageFilter" class="${currentDamageFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentDamageFilter === 'all' ? 'selected' : ''}>All Damage Status</option>
          ${damages.map(damage => `<option value="${damage.replace(/"/g, '&quot;')}" ${currentDamageFilter === damage ? 'selected' : ''}>${damage}</option>`).join('')}
        </select>
        <select id="persistentStatusFilter" class="${currentStatusFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentStatusFilter === 'all' ? 'selected' : ''}>All Household Status</option>
          ${statuses.map(status => `<option value="${status.replace(/"/g, '&quot;')}" ${currentStatusFilter === status ? 'selected' : ''}>${status}</option>`).join('')}
        </select>
        ${rebuildCol ? `<select id="persistentRebuildFilter" class="${currentRebuildFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentRebuildFilter === 'all' ? 'selected' : ''}>All Rebuild Status</option>
          ${rebuildStatusesArray.map(status => `<option value="${status.replace(/"/g, '&quot;')}" ${currentRebuildFilter === status ? 'selected' : ''}>${status}</option>`).join('')}
        </select>` : ''}
        ${contactDateCol ? `
        <div class="contact-filter-group">
          <label class="contact-filter-checkbox">
            <input type="checkbox" id="persistentShowContactedCheckbox" ${showContactedAddresses ? 'checked' : ''}>
            <span>Show contacted addresses</span>
          </label>
          <label class="contact-filter-checkbox">
            <input type="checkbox" id="persistentShowUncontactedCheckbox" ${showUncontactedAddresses ? 'checked' : ''}>
            <span>Show uncontacted addresses</span>
          </label>
        </div>
        ` : ''}
      `;

      filterBarContent.innerHTML = html;
      filterBar.style.display = 'block';

      // Add event handlers (remove old ones first to avoid duplicates)
      const oldStreetFilter = document.getElementById('persistentStreetFilter');
      if (oldStreetFilter) {
        oldStreetFilter.replaceWith(oldStreetFilter.cloneNode(true));
      }
      const oldDamageFilter = document.getElementById('persistentDamageFilter');
      if (oldDamageFilter) {
        oldDamageFilter.replaceWith(oldDamageFilter.cloneNode(true));
      }
      const oldStatusFilter = document.getElementById('persistentStatusFilter');
      if (oldStatusFilter) {
        oldStatusFilter.replaceWith(oldStatusFilter.cloneNode(true));
      }
      const oldRebuildFilter = document.getElementById('persistentRebuildFilter');
      if (oldRebuildFilter) {
        oldRebuildFilter.replaceWith(oldRebuildFilter.cloneNode(true));
      }
      const oldContactedCheckbox = document.getElementById('persistentShowContactedCheckbox');
      if (oldContactedCheckbox) {
        oldContactedCheckbox.replaceWith(oldContactedCheckbox.cloneNode(true));
      }
      const oldUncontactedCheckbox = document.getElementById('persistentShowUncontactedCheckbox');
      if (oldUncontactedCheckbox) {
        oldUncontactedCheckbox.replaceWith(oldUncontactedCheckbox.cloneNode(true));
      }

      // Add event handlers
      const streetFilter = document.getElementById('persistentStreetFilter');
      if (streetFilter) {
        streetFilter.addEventListener('change', (e) => {
          currentStreetFilter = e.target.value;
          if (currentStreetFilter !== 'all') {
            streetFilter.classList.add('filter-active');
          } else {
            streetFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const damageFilter = document.getElementById('persistentDamageFilter');
      if (damageFilter) {
        damageFilter.addEventListener('change', (e) => {
          currentDamageFilter = e.target.value;
          if (currentDamageFilter !== 'all') {
            damageFilter.classList.add('filter-active');
          } else {
            damageFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const statusFilter = document.getElementById('persistentStatusFilter');
      if (statusFilter) {
        statusFilter.addEventListener('change', (e) => {
          currentStatusFilter = e.target.value;
          if (currentStatusFilter !== 'all') {
            statusFilter.classList.add('filter-active');
          } else {
            statusFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const rebuildFilter = document.getElementById('persistentRebuildFilter');
      if (rebuildFilter) {
        rebuildFilter.addEventListener('change', (e) => {
          currentRebuildFilter = e.target.value;
          if (currentRebuildFilter !== 'all') {
            rebuildFilter.classList.add('filter-active');
          } else {
            rebuildFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const showContactedCheckbox = document.getElementById('persistentShowContactedCheckbox');
      if (showContactedCheckbox) {
        showContactedCheckbox.addEventListener('change', (e) => {
          showContactedAddresses = e.target.checked;
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const showUncontactedCheckbox = document.getElementById('persistentShowUncontactedCheckbox');
      if (showUncontactedCheckbox) {
        showUncontactedCheckbox.addEventListener('change', (e) => {
          showUncontactedAddresses = e.target.checked;
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }
    }

    // Display address table view for Addresses & People page
    function displayAddressTable() {
      if (!sheetData || !sheetData.addressMap) {
        const tableView = document.getElementById('peopleTableView');
        if (tableView) {
          tableView.innerHTML = '<div class="empty">Load a spreadsheet to see addresses</div>';
        }
        return;
      }
      
      const addresses = Array.from(sheetData.addressMap.keys()).sort();
      const tableView = document.getElementById('peopleTableView');
      if (!tableView) return;
      
      if (addresses.length === 0) {
        tableView.innerHTML = '<div class="empty">No addresses found</div>';
        return;
      }
      
      const headers = sheetData.headers;
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      const ageCol = headers.find(h => h.toLowerCase() === 'age');
      const phoneCol = headers.find(h => h.toLowerCase().includes('phone') && !h.toLowerCase().includes('nc'));
      const emailCol = headers.find(h => h.toLowerCase().includes('email'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      
      // Get unique values for filters
      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      const statuses = getUniqueStatus(addresses);
      
      // Get unique rebuild status values
      const rebuildStatuses = new Set();
      if (rebuildCol) {
        sheetData.data.forEach(row => {
          if (row[rebuildCol] !== undefined && row[rebuildCol] !== null) {
            const value = String(row[rebuildCol]).trim();
            if (value) rebuildStatuses.add(value);
          }
        });
      }
      const rebuildStatusesArray = Array.from(rebuildStatuses).sort();
      
      // Filter addresses
      const filteredAddresses = addresses.filter(addr => {
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) return false;
        if (currentDamageFilter !== 'all' && getAddressDamage(addr) !== currentDamageFilter) return false;
        if (currentStatusFilter !== 'all' && getAddressStatus(addr) !== currentStatusFilter) return false;
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const rebuildValue = (rows[0][rebuildCol] || '').trim();
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(addr);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        return true;
      });
      
      // Sort addresses if sort column is set
      let sortedAddresses = [...filteredAddresses];
      if (tableSortColumn) {
        sortedAddresses.sort((a, b) => {
          const rowsA = sheetData.addressMap.get(a);
          const rowsB = sheetData.addressMap.get(b);
          let valA = '';
          let valB = '';
          
          if (tableSortColumn === 'address') {
            valA = a;
            valB = b;
          } else if (tableSortColumn === 'residents') {
            const residentsA = rowsA && residentNameCol ? rowsA.filter(r => r[residentNameCol]?.trim()).length : 0;
            const residentsB = rowsB && residentNameCol ? rowsB.filter(r => r[residentNameCol]?.trim()).length : 0;
            valA = residentsA.toString();
            valB = residentsB.toString();
          } else {
            const col = headers.find(h => h.toLowerCase() === tableSortColumn.toLowerCase());
            if (col) {
              valA = rowsA && rowsA[0] ? (rowsA[0][col] || '').toString().trim() : '';
              valB = rowsB && rowsB[0] ? (rowsB[0][col] || '').toString().trim() : '';
            }
          }
          
          const comparison = valA.localeCompare(valB, undefined, { numeric: true, sensitivity: 'base' });
          return tableSortDirection === 'asc' ? comparison : -comparison;
        });
      }
      
      const html = `
        <div class="address-table-container">
          <table class="address-table">
            <thead>
              <tr>
                <th class="sortable" data-sort="address" title="Click to sort">Address ${tableSortColumn === 'address' ? (tableSortDirection === 'asc' ? 'â†‘' : 'â†“') : ''}</th>
                <th class="sortable" data-sort="residents" title="Click to sort">Residents ${tableSortColumn === 'residents' ? (tableSortDirection === 'asc' ? 'â†‘' : 'â†“') : ''}</th>
                ${damageCol ? `<th class="sortable" data-sort="${damageCol.toLowerCase()}" title="Click to sort">Damage ${tableSortColumn === damageCol.toLowerCase() ? (tableSortDirection === 'asc' ? 'â†‘' : 'â†“') : ''}</th>` : ''}
                ${statusCol ? `<th class="sortable" data-sort="${statusCol.toLowerCase()}" title="Click to sort">Household Status ${tableSortColumn === statusCol.toLowerCase() ? (tableSortDirection === 'asc' ? 'â†‘' : 'â†“') : ''}</th>` : ''}
                ${rebuildCol ? `<th class="sortable" data-sort="${rebuildCol.toLowerCase()}" title="Click to sort">Rebuild Status ${tableSortColumn === rebuildCol.toLowerCase() ? (tableSortDirection === 'asc' ? 'â†‘' : 'â†“') : ''}</th>` : ''}
                ${ageCol ? `<th class="sortable" data-sort="${ageCol.toLowerCase()}" title="Click to sort">Age ${tableSortColumn === ageCol.toLowerCase() ? (tableSortDirection === 'asc' ? 'â†‘' : 'â†“') : ''}</th>` : ''}
                ${phoneCol ? `<th>Phone</th>` : ''}
                ${emailCol ? `<th>Email</th>` : ''}
                ${contactDateCol ? `<th class="sortable" data-sort="${contactDateCol.toLowerCase()}" title="Click to sort">Last Contact ${tableSortColumn === contactDateCol.toLowerCase() ? (tableSortDirection === 'asc' ? 'â†‘' : 'â†“') : ''}</th>` : ''}
              </tr>
            </thead>
            <tbody>
              ${sortedAddresses.map(addr => {
                const rows = sheetData.addressMap.get(addr);
                const residents = [];
                if (rows && residentNameCol) {
                  rows.forEach(row => {
                    if (row[residentNameCol] && row[residentNameCol].trim()) {
                      residents.push(row[residentNameCol].trim());
                    }
                  });
                }
                const damage = damageCol && rows && rows[0] ? (rows[0][damageCol] || '').trim() : '';
                const status = statusCol && rows && rows[0] ? (rows[0][statusCol] || '').trim() : '';
                const rebuild = rebuildCol && rows && rows[0] ? (rows[0][rebuildCol] || '').trim() : '';
                const age = ageCol && rows && rows[0] ? (rows[0][ageCol] || '').trim() : '';
                const phone = phoneCol && rows && rows[0] ? (rows[0][phoneCol] || '').trim() : '';
                const email = emailCol && rows && rows[0] ? (rows[0][emailCol] || '').trim() : '';
                const contactDate = contactDateCol && rows && rows[0] ? (rows[0][contactDateCol] || '').trim() : '';
                
                // Format residents with truncation
                let residentsDisplay = '-';
                if (residents.length > 0) {
                  const residentsText = residents.join(', ');
                  const totalCount = residents.length;
                  // If text is long, truncate and show count
                  if (residentsText.length > 40) {
                    residentsDisplay = residentsText.substring(0, 37) + '... (' + totalCount + ' Total)';
                  } else {
                    residentsDisplay = residentsText;
                  }
                }
                
                return `
                  <tr class="table-address-row" data-address="${addr.replace(/"/g, '&quot;')}">
                    <td title="${addr}">${addr}</td>
                    <td title="${residents.length > 0 ? residents.join(', ') : '-'}">${residentsDisplay}</td>
                    ${damageCol ? `<td>${damage || '-'}</td>` : ''}
                    ${statusCol ? `<td>${status || '-'}</td>` : ''}
                    ${rebuildCol ? `<td>${rebuild || '-'}</td>` : ''}
                    ${ageCol ? `<td>${age || '-'}</td>` : ''}
                    ${phoneCol ? `<td>${phone || '-'}</td>` : ''}
                    ${emailCol ? `<td>${email || '-'}</td>` : ''}
                    ${contactDateCol ? `<td>${contactDate || '-'}</td>` : ''}
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;
      
      tableView.innerHTML = html;
      
      // Add sortable column handlers
      document.querySelectorAll('.sortable').forEach(th => {
        th.style.cursor = 'pointer';
        th.addEventListener('click', () => {
          const sortCol = th.getAttribute('data-sort');
          if (tableSortColumn === sortCol) {
            // Toggle direction if same column
            tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            // New column, default to ascending
            tableSortColumn = sortCol;
            tableSortDirection = 'asc';
          }
          displayAddressTable();
        });
      });
      
      // Add row click handlers
      document.querySelectorAll('.table-address-row').forEach(row => {
        row.addEventListener('click', () => {
          const address = row.getAttribute('data-address');
          // Update selected state
          document.querySelectorAll('.table-address-row').forEach(r => r.classList.remove('selected'));
          row.classList.add('selected');
          // Show details in floating panel
          displayAddressDetails(address);
          // Switch to people view if not already
          if (currentView !== 'people') {
            switchView('people');
          }
        });
      });
    }

    function displayAddressList(addresses) {
      // Clear selected address when showing list
      selectedAddress = null;
      
      if (addresses.length === 0) {
        addressPanelContent.innerHTML = '<div class="empty">No addresses found</div>';
        return;
      }

      // Get unique values for all filters
      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      const statuses = getUniqueStatus(addresses);
      
      // Filter addresses by all selected filters (same logic as displayAddressTable)
      const headers = sheetData.headers;
      const rebuildCol = headers.find(h => h.toLowerCase().includes('rebuild'));
      const contactDateCol = headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      
      const filteredAddresses = addresses.filter(addr => {
        // Street filter
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) {
          return false;
        }
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const addrDamage = getAddressDamage(addr);
          if (addrDamage !== currentDamageFilter) {
            return false;
          }
        }
        // Status filter
        if (currentStatusFilter !== 'all') {
          const addrStatus = getAddressStatus(addr);
          if (addrStatus !== currentStatusFilter) {
            return false;
          }
        }
        // Rebuild filter
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const rebuildValue = (rows[0][rebuildCol] || '').trim();
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(addr);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        return true;
      });

      const html = `
        <ul class="address-list">
          ${filteredAddresses.map(addr => `
            <li class="address-item" data-address="${addr.replace(/"/g, '&quot;')}">
              ${addr}
            </li>
          `).join('')}
        </ul>
      `;
      
      addressPanelContent.innerHTML = html;

      // Add click handlers
      document.querySelectorAll('.address-item').forEach(item => {
        item.addEventListener('click', () => {
          const address = item.getAttribute('data-address');
          displayAddressDetails(address);
          
          // Update active state
          document.querySelectorAll('.address-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
        });
      });
    }

    // Display details for a specific address
    function displayAddressDetails(address, preserveScroll = false) {
      if (!sheetData.addressMap || !sheetData.addressMap.has(address)) {
        return;
      }

      // Track selected address
      selectedAddress = address;
      
      // Highlight the corresponding marker on the map
      highlightSelectedMarker(address);
      
      // Save scroll position if we're refreshing
      if (preserveScroll) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      const rows = sheetData.addressMap.get(address);
      const { headers, addressCol } = sheetData;

      // Find relevant columns (exclude address column itself)
      const detailCols = headers.filter(h => 
        h !== addressCol && 
        h.toLowerCase() !== 'address' &&
        rows.some(row => row[h] && row[h].trim())
      );
      
      // Define which address-level fields to DISPLAY (others are hidden)
      // Note: "address" is excluded since it's shown as the heading
      const addressLevelDisplayFields = [
        'household size',
        'damage',
        'household status',
        'address notes'
      ];
      
      // Separate address-level and person-level columns
      const addressLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Explicitly exclude person-level notes and email address
        if (lower.includes('person note')) return false;
        if (lower.includes('email address')) return false;
        // Address-level: fields that are the same for all people at this address
        // But only include if they're in the display list
        const isSameForAll = rows.length > 0 && rows.every(r => (r[h] || '').trim() === (rows[0][h] || '').trim());
        const shouldDisplay = addressLevelDisplayFields.some(field => lower.includes(field));
        return isSameForAll && shouldDisplay;
      });
      
      // Fields to hide from person view
      const hiddenFromPersonView = [
        'house #',
        'street',
        'city',
        'state',
        'zip_code',
        'resident name',
        'zone',
        'nc name',
        'nc email',
        'damage',
        'household status',
        'household size',
        'latitude',
        'longitude',
        'nc phone',
        'first name',
        'middle name',
        'last name'
      ];
      
      const personLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Skip hidden fields
        if (hiddenFromPersonView.some(field => lower.includes(field))) return false;
        // Skip Contact Notes - it's shown separately in contact mode
        if (lower.includes('contact') && lower.includes('note')) return false;
        // Person-level: Person Notes, Person Notes 2, Person Notes 3, or person-specific fields
        return lower.includes('person note') ||
               lower.includes('home phone') ||
               lower.includes('cell') ||
               lower.includes('email address') ||
               lower.includes('gender') ||
               lower.includes('age') ||
               (!addressLevelCols.includes(h) && detailCols.includes(h));
      });
      
      // Find Notes columns separately - always show them if signed in, even if empty
      // Exclude Contact Notes - it's shown separately in contact mode
      const allNotesCols = headers.filter(h => 
        h !== addressCol &&
        h.toLowerCase().includes('note') &&
        !(h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')) &&
        accessToken // Only if signed in
      );
      
      // Add Notes columns to detailCols if not already there
      allNotesCols.forEach(col => {
        if (!detailCols.includes(col)) {
          detailCols.push(col);
        }
      });

      let html = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; gap: 12px;">
          <button class="btn-back" onclick="displayAddressList(Array.from(sheetData.addressMap.keys()).sort())">â† Back to List</button>
          ${accessToken ? `
            <div style="display: flex; gap: 6px; align-items: flex-start; position: relative;">
              <div style="display: flex; flex-direction: column; align-items: flex-end; height: 50px; justify-content: flex-start;">
                <div style="display: flex; gap: 6px; align-items: center; margin-bottom: 2px;">
                  <button class="btn-save btn-save-small" id="saveChangesBtnTop" style="margin: 0; align-self: center;">Save Changes</button>
                  <button class="btn-refresh-small" id="refreshBtnTop" title="Refresh addresses now" style="margin: 0;">â†»</button>
                </div>
                <span class="save-status save-status-top" id="saveStatusTop"></span>
              </div>
            </div>
          ` : ''}
        </div>
        <div class="address-details active">
          <h3>${address}</h3>
      `;

      // Collect unique values for dropdown fields from ALL data
      const damageValues = new Set();
      const statusValues = new Set();
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      
      // Default status values (in case not all are found in data)
      const defaultDamageValues = ['Total Loss', 'Partial Loss', 'Standing'];
      const defaultStatusValues = ['Planning to Rebuild', 'Selling', 'Renter/Moved', 'Staying'];
      
      sheetData.data.forEach(row => {
        if (damageCol && row[damageCol] !== undefined && row[damageCol] !== null) {
          const value = String(row[damageCol]).trim();
          if (value) damageValues.add(value);
        }
        if (statusCol && row[statusCol] !== undefined && row[statusCol] !== null) {
          const value = String(row[statusCol]).trim();
          if (value) statusValues.add(value);
        }
      });
      
      // Add default values if they weren't found (ensures all options are available)
      if (damageCol) {
        defaultDamageValues.forEach(val => damageValues.add(val));
      }
      if (statusCol) {
        defaultStatusValues.forEach(val => statusValues.add(val));
      }
      
      console.log('Damage values found:', Array.from(damageValues));
      console.log('Status values found:', Array.from(statusValues));

      // Show address-level fields once at the top (always show, not just when signed in)
      if (addressLevelCols.length > 0) {
        html += '<div class="address-level-section" style="background: rgba(255,255,255,0.7); padding: 12px; border-radius: 6px; margin-bottom: 16px; border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 1px 3px rgba(0,0,0,0.04);">';
        
        addressLevelCols.forEach(col => {
          const firstRowValue = rows[0] ? (rows[0][col] || '') : '';
          const lower = col.toLowerCase();
          const isNotes = lower.includes('note');
          const isDamage = lower.includes('damage');
          const isStatus = lower.includes('household status');
          const isEditable = accessToken; // All fields editable when signed in
          
          if (isEditable) {
            if (isNotes) {
              // Notes: expandable textarea
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-address-level="true"
                     data-column="${col}"
                     data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue}</textarea>
              </div>`;
            } else if (isDamage || isStatus) {
              // Damage/Status: dropdown
              const options = isDamage ? Array.from(damageValues).sort() : Array.from(statusValues).sort();
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <select class="editable-dropdown" 
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">
                  <option value="">(not set)</option>
                  ${options.map(opt => `<option value="${opt.replace(/"/g, '&quot;')}" ${opt === firstRowValue ? 'selected' : ''}>${opt}</option>`).join('')}
                </select>
              </div>`;
            } else {
              // Other fields: subtle editable
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-address-level="true"
                      data-column="${col}"
                      data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue || ''}</span>
              </div>`;
            }
          } else {
            // Not signed in: display only
            html += `<div class="person-info"><strong>${col}:</strong> ${firstRowValue || '(not set)'}</div>`;
          }
        });
        
        html += '</div>';
      }

      // Check if contact mode is active
      const isContactMode = window.contactModeActive || false;
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );

      // Show person-level fields for each person
      rows.forEach((row, index) => {
        // Get the original row index that was stored when grouping
        const originalRowIndex = row.__originalIndex !== undefined ? row.__originalIndex : -1;
        
        // Check contact status
        const lastContact = lastContactCol ? (row[lastContactCol] || '').trim() : '';
        const isContacted = lastContact && lastContact.length > 0;
        const contactClass = isContacted ? 'recent-contact' : (isContactMode ? 'no-contact' : '');
        
        html += `<div class="person-entry ${contactClass}">`;
        
        // Try to find name column - show Resident Name as the person's name
        const nameCol = headers.find(h => 
          h.toLowerCase().includes('resident name') || 
          (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name'))
        );
        
        if (nameCol && row[nameCol]) {
          html += `<div class="person-name">${row[nameCol]}</div>`;
        } else if (rows.length > 1) {
          html += `<div class="person-name">Person ${index + 1}</div>`;
        }

        // Contact mode: show contact button and quick notes
        if (isContactMode && accessToken) {
          html += `
            <div style="margin-top: 8px; margin-bottom: 8px;">
              <button class="contact-button ${isContacted ? 'contacted' : ''}" 
                      data-address="${address.replace(/"/g, '&quot;')}"
                      data-original-row-index="${originalRowIndex}"
                      data-column="${lastContactCol || 'Last Contact Date'}"
                      onclick="markContact(this, '${address.replace(/"/g, '&quot;')}', ${originalRowIndex}, '${lastContactCol || 'Last Contact Date'}')">
                ${isContacted ? 'âœ“ Contacted' : 'Mark as Contacted'}
              </button>
              ${isContacted ? `<div class="contact-date">Last contact: ${lastContact}</div>` : ''}
              <textarea class="contact-notes-quick" 
                        placeholder="Quick contact notes..."
                        data-address="${address.replace(/"/g, '&quot;')}"
                        data-original-row-index="${originalRowIndex}"
                        data-column="Contact Notes"
                        data-original-value="${(row['Contact Notes'] || '').replace(/"/g, '&quot;')}">${row['Contact Notes'] || ''}</textarea>
            </div>
          `;
        } else if (isContactMode && !accessToken) {
          // Contact mode but not signed in - show status only
          html += `
            <div style="margin-top: 8px; margin-bottom: 8px;">
              <div style="font-size: 0.85rem; color: ${isContacted ? '#4caf50' : '#ff9800'};">
                ${isContacted ? `âœ“ Contacted (${lastContact})` : 'âš  Not contacted'}
              </div>
            </div>
          `;
        }

        // Display person-level fields (show even if empty, like Notes)
        personLevelCols.forEach(col => {
          const isNotes = col.toLowerCase().includes('note');
          const isEditable = accessToken; // All fields editable when signed in
          
          // Skip Resident Name since we already show it as the person's name
          if (col.toLowerCase().includes('resident name')) return;
          
          // Skip Contact Notes if we're in contact mode (already shown as Quick Contact Notes)
          if (isContactMode && (col.toLowerCase().includes('contact') && col.toLowerCase().includes('note'))) return;
          
          if (isEditable) {
            if (isNotes) {
              // Notes: expandable textarea
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-original-row-index="${originalRowIndex}" 
                     data-column="${col}"
                     data-address-level="false"
                     data-original-value="${(row[col] || '').replace(/"/g, '&quot;')}">${row[col] || ''}</textarea>
              </div>`;
            } else {
              // Other fields: subtle editable
              const value = row[col] || '';
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-original-row-index="${originalRowIndex}" 
                      data-column="${col}"
                      data-address-level="false"
                      data-original-value="${value.replace(/"/g, '&quot;')}">${value || ''}</span>
              </div>`;
            }
          } else {
            // Show all person-level fields, even if empty
            const value = row[col] || '';
            html += `<div class="person-info"><strong>${col}:</strong> ${value || '(not set)'}</div>`;
          }
        });
        
        // Display other non-notes fields that aren't address-level (but exclude hidden fields)
        detailCols.forEach(col => {
          const lower = col.toLowerCase();
          const isHidden = hiddenFromPersonView.some(field => lower.includes(field));
          if (!addressLevelCols.includes(col) && !personLevelCols.includes(col) && 
              !col.toLowerCase().includes('note') && !isHidden) {
            if (row[col] && row[col].trim()) {
              html += `<div class="person-info"><strong>${col}:</strong> ${row[col]}</div>`;
            }
          }
        });

        html += '</div>';
      });

      // Add save button if signed in and there are editable fields
      if (accessToken) {
        html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 2px solid var(--river);">
            <button class="btn-save" id="saveChangesBtn">Save Changes</button>
            <span class="save-status" id="saveStatus"></span>
          </div>
        `;
      }

      html += '</div>';
      addressPanelContent.innerHTML = html;
      
      // Add save button handlers (both top and bottom buttons)
      const saveBtn = document.getElementById('saveChangesBtn');
      if (saveBtn) {
        saveBtn.addEventListener('click', saveChanges);
      }
      const saveBtnTop = document.getElementById('saveChangesBtnTop');
      if (saveBtnTop) {
        saveBtnTop.addEventListener('click', saveChanges);
      }
      const refreshBtnTop = document.getElementById('refreshBtnTop');
      if (refreshBtnTop) {
        refreshBtnTop.addEventListener('click', () => {
          if (currentSheetUrl) {
            loadAddressData(currentSheetUrl);
          }
        });
      }
      
      // Add change handlers for dropdowns with auto-save
      document.querySelectorAll('.editable-dropdown').forEach(dropdown => {
        dropdown.addEventListener('change', () => {
          // Mark as changed for save
          dropdown.setAttribute('data-changed', 'true');
          // Trigger auto-save
          triggerAutoSave();
        });
      });
      
      // Add change handlers for contenteditable fields with auto-save
      document.querySelectorAll('.editable-field[contenteditable="true"], .editable-inline[contenteditable="true"]').forEach(field => {
        field.addEventListener('input', () => {
          triggerAutoSave();
        });
        field.addEventListener('blur', () => {
          // Also trigger on blur in case user clicks away
          triggerAutoSave();
        });
      });
      
      // Add change handlers for textareas with auto-save
      document.querySelectorAll('.editable-notes, .contact-notes-quick').forEach(textarea => {
        textarea.addEventListener('input', () => {
          triggerAutoSave();
        });
        textarea.addEventListener('blur', () => {
          triggerAutoSave();
        });
      });
      
      // Restore scroll position if refreshing, otherwise scroll to top
      setTimeout(() => {
        if (preserveScroll) {
          addressPanelContent.scrollTop = savedScrollPosition;
        } else {
          addressPanelContent.scrollTop = 0; // Start at top for new address
        }
      }, 0);
    }

    // Load sheet button handler
    btn.addEventListener("click", () => {
      let url = input.value.trim();
      if (!url) return;

      if (url.includes("/view")) {
        url = url.replace("/view", "/edit");
      }

      currentSheetUrl = url;
      // Save to localStorage
      localStorage.setItem('savedSheetUrl', url);
      
      // Load the address data
      loadAddressData(url);
    });

    // Refresh button handler
    // Refresh button removed - data auto-loads after sign-in

    // Navigation System - Single Page Navigation
    function switchView(viewName) {
      currentView = viewName;
      
      // Hide all content views
      document.querySelectorAll('.content-view').forEach(view => {
        view.style.display = 'none';
        view.classList.remove('active');
      });
      
      // Update nav items
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
      
      // Show selected view (map view doesn't need a content overlay)
      if (viewName !== 'map') {
        const selectedView = document.getElementById(viewName + 'View');
        if (selectedView) {
          selectedView.style.display = 'block';
          selectedView.classList.add('active');
        }
      }
      
      // Update nav button
      const navButton = document.getElementById('nav' + viewName.charAt(0).toUpperCase() + viewName.slice(1));
      if (navButton) {
        navButton.classList.add('active');
      }
      
      // Show/hide floating panel based on view
      const floatingPanel = document.getElementById('floatingPanel');
      if (viewName === 'people' || viewName === 'map') {
        // Show floating panel for people and map views
        if (floatingPanel) floatingPanel.style.display = 'flex';
      } else {
        // Hide floating panel for other views
        if (floatingPanel) floatingPanel.style.display = 'none';
      }
      
      // Show/hide filter bar based on view
      const filterBar = document.getElementById('filterBar');
      const shouldShowFilters = (viewName === 'people' || viewName === 'map');
      if (shouldShowFilters) {
        // Show filter bar for people and map views
        if (filterBar && sheetData && sheetData.addressMap) {
          filterBar.style.display = 'block';
        }
        // Adjust content views to account for filter bar
        document.querySelectorAll('.content-view').forEach(view => {
          view.style.top = '80px';
        });
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.style.top = '80px';
        }
      } else {
        // Hide filter bar for other views
        if (filterBar) filterBar.style.display = 'none';
        // Adjust content views to start at top (no filter bar)
        document.querySelectorAll('.content-view').forEach(view => {
          view.style.top = '0';
        });
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.style.top = '0';
        }
      }
      
      // Update content based on view
      if (viewName === 'people' && sheetData && sheetData.addressMap) {
        displayAddressTable();
      } else if (viewName === 'progress' && sheetData && sheetData.addressMap) {
        updateZoneProgressCharts();
      }
      // Map view doesn't need special content updates - it just shows the map with floating panel
    }
    
    // Set up navigation event listeners
    document.querySelectorAll('.nav-item[data-view]').forEach(item => {
      item.addEventListener('click', (e) => {
        const viewName = e.target.getAttribute('data-view');
        switchView(viewName);
      });
    });
    
    // Initialize with map view (shows map with floating panel)
    switchView('map');

    // Convert column index to letter (A, B, C, etc.) - global helper function
    function indexToColumnLetter(index) {
      let result = '';
      while (index >= 0) {
        result = String.fromCharCode(65 + (index % 26)) + result;
        index = Math.floor(index / 26) - 1;
      }
      return result;
    }

    // Save changes to spreadsheet
    // Debounced auto-save function
    function triggerAutoSave() {
      // Clear existing timer
      if (autoSaveTimer) {
        clearTimeout(autoSaveTimer);
      }
      
      // Set new timer (1.2 seconds delay)
      autoSaveTimer = setTimeout(() => {
        saveChanges(true); // true = isAutoSave
      }, 1200);
      
      // Show "Auto-saving..." indicator in both locations (top and bottom)
      const saveStatus = document.getElementById('saveStatus');
      const saveStatusTop = document.getElementById('saveStatusTop');
      
      if (saveStatus) {
        saveStatus.textContent = 'Auto-saving...';
        saveStatus.className = 'save-status saving';
      }
      if (saveStatusTop) {
        saveStatusTop.textContent = 'Auto-saving...';
        saveStatusTop.className = 'save-status saving';
      }
    }

    async function saveChanges(isAutoSave = false) {
      if (!accessToken || !currentSheetId) {
        if (!isAutoSave) {
          alert('Please sign in to save changes.');
        }
        return;
      }

      const saveBtn = document.getElementById('saveChangesBtn');
      const saveStatus = document.getElementById('saveStatus');
      const saveStatusTop = document.getElementById('saveStatusTop');
      // Get all editable elements: Notes fields (textareas), inline fields, dropdowns, and Quick Contact Notes
      const editableFields = document.querySelectorAll('.editable-field[contenteditable="true"], .editable-inline[contenteditable="true"], .editable-notes, .contact-notes-quick');
      const editableDropdowns = document.querySelectorAll('.editable-dropdown');
      
      if (editableFields.length === 0 && editableDropdowns.length === 0) {
        return;
      }

      if (!saveBtn || !saveStatus) {
        console.warn('Save button or status element not found');
        return;
      }

      saveBtn.disabled = true;
      if (saveStatus) {
        saveStatus.textContent = isAutoSave ? 'Auto-saving...' : 'Saving...';
        saveStatus.className = 'save-status saving';
      }
      if (saveStatusTop) {
        saveStatusTop.textContent = isAutoSave ? 'Auto-saving...' : 'Saving...';
        saveStatusTop.className = 'save-status saving';
      }

      try {
        // Collect all changes
        const updates = [];
        editableFields.forEach(field => {
          // Handle textareas differently from contenteditable divs
          const newValue = field.tagName === 'TEXTAREA' ? field.value.trim() : field.textContent.trim();
          const originalValue = field.getAttribute('data-original-value') || '';
          const column = field.getAttribute('data-column');
          const isAddressLevel = field.getAttribute('data-address-level') === 'true';
          const address = field.getAttribute('data-address');
          const originalRowIndex = parseInt(field.getAttribute('data-original-row-index'));

          if (newValue !== originalValue) {
            // Find the column index - handle Contact Notes with flexible matching
            let colIndex = -1;
            if (column === 'Contact Notes' || field.classList.contains('contact-notes-quick')) {
              // For Contact Notes, use flexible search like markContact does
              colIndex = sheetData.headers.findIndex(h => 
                h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')
              );
            } else {
              colIndex = sheetData.headers.indexOf(column);
            }
            if (colIndex === -1) {
              console.warn(`Column not found: ${column}`);
              return;
            }

            // Convert column index to letter (A, B, C, etc.)
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            } else {
              // Person-level: update only this specific row
              if (originalRowIndex !== -1) {
                const rowNumber = originalRowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                const range = `${colLetter}${rowNumber}`;
                updates.push({
                  range: `Sheet1!${range}`,
                  values: [[newValue]]
                });
              }
            }
          }
        });
        
        // Handle dropdown fields
        editableDropdowns.forEach(dropdown => {
          const newValue = dropdown.value.trim();
          const originalValue = dropdown.getAttribute('data-original-value');
          const column = dropdown.getAttribute('data-column');
          const isAddressLevel = dropdown.getAttribute('data-address-level') === 'true';
          const address = dropdown.getAttribute('data-address');

          if (newValue !== originalValue) {
            // Find the column index
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex === -1) return;

            // Convert column index to letter
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2;
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            }
          }
        });

        if (updates.length === 0) {
          if (saveStatus) {
            saveStatus.textContent = 'No changes to save';
            saveStatus.className = 'save-status';
          }
          if (saveBtn) {
            saveBtn.disabled = false;
          }
          return;
        }

        // Use Google Sheets API to update
        const response = await fetch(
          `https://sheets.googleapis.com/v4/spreadsheets/${currentSheetId}/values:batchUpdate`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              valueInputOption: 'USER_ENTERED',
              data: updates
            })
          }
        );

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'Failed to save');
        }

        // Update original values
        editableFields.forEach(field => {
          const value = field.tagName === 'TEXTAREA' ? field.value.trim() : field.textContent.trim();
          // Escape HTML entities for data attribute
          const escapedValue = value.replace(/"/g, '&quot;').replace(/\n/g, '&#10;');
          field.setAttribute('data-original-value', escapedValue);
        });
        editableDropdowns.forEach(dropdown => {
          dropdown.setAttribute('data-original-value', dropdown.value.trim());
        });

        if (saveStatus) {
          saveStatus.textContent = isAutoSave ? 'Auto-saved!' : 'Saved!';
          saveStatus.className = 'save-status saved';
          // Clear auto-save message after 2 seconds
          if (isAutoSave) {
            setTimeout(() => {
              if (saveStatus && saveStatus.textContent === 'Auto-saved!') {
                saveStatus.textContent = '';
                saveStatus.className = 'save-status';
              }
            }, 2000);
          }
        }
        if (saveStatusTop) {
          saveStatusTop.textContent = isAutoSave ? 'Auto-saved!' : 'Saved!';
          saveStatusTop.className = 'save-status saved';
          // Clear auto-save message after 2 seconds
          if (isAutoSave) {
            setTimeout(() => {
              if (saveStatusTop && saveStatusTop.textContent === 'Auto-saved!') {
                saveStatusTop.textContent = '';
                saveStatusTop.className = 'save-status';
              }
            }, 2000);
          }
        }
        
        // Refresh data after a short delay (only for manual saves to avoid too many refreshes)
        if (!isAutoSave) {
          setTimeout(() => {
            if (currentSheetUrl) {
              loadAddressData(currentSheetUrl);
            }
          }, 1000);
        }

      } catch (error) {
        console.error('Save error:', error);
        if (saveStatus) {
          saveStatus.textContent = `Error: ${error.message}`;
          saveStatus.className = 'save-status error';
        }
        if (saveStatusTop) {
          saveStatusTop.textContent = `Error: ${error.message}`;
          saveStatusTop.className = 'save-status error';
        }
        // For auto-save errors, also show a console warning (less intrusive than alert)
        if (isAutoSave) {
          console.warn('Auto-save failed:', error.message);
        } else {
          alert(`Error saving changes: ${error.message}`);
        }
      } finally {
        if (saveBtn) {
          saveBtn.disabled = false;
        }
      }
    }

    // Initialize Leaflet map
    function initializeMap() {
      const mapDiv = document.getElementById('zoneMap');
      if (!mapDiv) {
        console.error('Map div not found');
        return;
      }
      
      if (!zoneMap) {
        try {
          // Default center (Altadena, CA - adjust as needed)
          zoneMap = L.map('zoneMap').setView([34.19, -118.15], 13);
          
          // Add OpenStreetMap tiles (default)
          currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(zoneMap);
          
          // Create satellite toggle control
          const SatelliteToggleControl = L.Control.extend({
            onAdd: function(map) {
              const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
              const button = L.DomUtil.create('a', 'satellite-toggle-btn', container);
              button.href = '#';
              button.title = 'Switch to satellite view';
              button.innerHTML = 'ðŸ›°ï¸';
              button.style.cssText = 'width: 30px; height: 30px; line-height: 30px; text-align: center; text-decoration: none; display: block; font-size: 18px;';
              
              L.DomEvent.disableClickPropagation(button);
              L.DomEvent.on(button, 'click', L.DomEvent.stop);
              L.DomEvent.on(button, 'click', () => {
                if (!zoneMap) return;
                
                // Remove current tile layer
                if (currentTileLayer) {
                  zoneMap.removeLayer(currentTileLayer);
                }
                
                // Toggle between street and satellite
                if (isSatelliteMode) {
                  // Switch to street map
                  currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors',
                    maxZoom: 19
                  }).addTo(zoneMap);
                  button.innerHTML = 'ðŸ›°ï¸';
                  button.title = 'Switch to satellite view';
                  isSatelliteMode = false;
                } else {
                  // Switch to satellite - using Google Satellite for more recent imagery
                  currentTileLayer = L.tileLayer('https://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                    subdomains: ['0', '1', '2', '3'],
                    attribution: 'Â© Google',
                    maxZoom: 20
                  }).addTo(zoneMap);
                  button.innerHTML = 'ðŸ—ºï¸';
                  button.title = 'Switch to street map';
                  isSatelliteMode = true;
                }
              });
              
              return container;
            }
          });
          
          // Add satellite toggle control next to zoom controls
          new SatelliteToggleControl({ position: 'topleft' }).addTo(zoneMap);
          
          // Invalidate size to ensure map renders correctly in full screen
          setTimeout(() => {
            if (zoneMap) {
              zoneMap.invalidateSize();
            }
          }, 100);
          
          console.log('Map initialized');
        } catch (error) {
          console.error('Error initializing map:', error);
        }
      } else {
        // If map already exists, invalidate size in case container changed
        setTimeout(() => {
          if (zoneMap) {
            zoneMap.invalidateSize();
          }
        }, 100);
      }
      
      // Load KML if URL is provided (commented out for now)
      // const kmlUrlInput = document.getElementById("kmlUrlInput");
      // const kmlUrl = kmlUrlInput && kmlUrlInput.value ? kmlUrlInput.value.trim() : '';
      // if (kmlUrl) {
      //   loadKMLBoundary(kmlUrl);
      // }
    }

    // Convert Google Drive sharing URL to direct download URL
    function convertGoogleDriveUrl(url) {
      // Extract file ID from Google Drive sharing URL
      // Format: https://drive.google.com/file/d/FILE_ID/view?usp=sharing
      // Or: https://drive.google.com/open?id=FILE_ID
      let fileId = null;
      
      // Try pattern 1: /file/d/FILE_ID/
      const match1 = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
      if (match1 && match1[1]) {
        fileId = match1[1];
      } else {
        // Try pattern 2: ?id=FILE_ID
        const match2 = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
        if (match2 && match2[1]) {
          fileId = match2[1];
        }
      }
      
      if (fileId) {
        // Try alternative Google Drive export URL format
        // The confirm=t parameter sometimes helps bypass virus scan
        return `https://drive.google.com/uc?export=download&id=${fileId}&confirm=t`;
      }
      
      // If it's already a direct download URL or other format, return as-is
      return url;
    }

    // Load KML boundary
    async function loadKMLBoundary(kmlUrl) {
      if (!kmlUrl || !kmlUrl.trim()) {
        console.log('No KML URL provided');
        return;
      }
      
      try {
        // Remove existing KML layer
        if (kmlLayer) {
          zoneMap.removeLayer(kmlLayer);
        }
        
        // Clean the URL - remove any quotes or extra whitespace
        const cleanUrl = kmlUrl.replace(/^["']|["']$/g, '').trim();
        console.log('Cleaned KML URL:', cleanUrl);
        
        // Convert Google Drive URL if needed
        const directUrl = convertGoogleDriveUrl(cleanUrl);
        console.log('Loading KML from:', directUrl);
        
        // Fetch KML file with CORS proxy fallback and timeout handling
        let kmlText;
        try {
          // Try direct fetch first with timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          try {
            const response = await fetch(directUrl, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              throw new Error(`Direct fetch failed: ${response.status}`);
            }
            kmlText = await response.text();
          } catch (fetchError) {
            clearTimeout(timeoutId);
            throw fetchError; // Re-throw to be caught by outer catch
          }
        } catch (error) {
          // If direct fetch fails (CORS issue or timeout), try multiple proxy services
          if (error.name === 'AbortError') {
            console.log('Direct fetch timed out, trying CORS proxy...');
          } else {
            console.log('Direct fetch failed, trying CORS proxy...', error);
          }
          
          // Try multiple proxy services with fallback
          const proxyServices = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(directUrl)}`,
            `https://corsproxy.io/?${encodeURIComponent(directUrl)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(directUrl)}`
          ];
          
          let lastError = null;
          let success = false;
          
          for (const proxyUrl of proxyServices) {
            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout for proxy
              
              const response = await fetch(proxyUrl, { signal: controller.signal });
              clearTimeout(timeoutId);
              
              if (response.ok) {
                kmlText = await response.text();
                success = true;
                console.log('Successfully loaded KML via proxy:', proxyUrl);
                break; // Success, exit loop
              } else {
                lastError = new Error(`Proxy returned ${response.status}: ${response.statusText}`);
                console.log(`Proxy ${proxyUrl} returned ${response.status}`);
              }
            } catch (proxyError) {
              if (proxyError.name === 'AbortError') {
                lastError = new Error('Proxy request timed out');
              } else {
                lastError = proxyError;
              }
              console.log(`Proxy ${proxyUrl} failed:`, lastError.message);
              continue; // Try next proxy
            }
          }
          
          if (!success) {
            throw new Error(`Failed to fetch KML: ${lastError ? lastError.message : 'All proxy services failed'}. The KML file may be too large, the URL may be invalid, or the file may not be publicly accessible. Try using a direct download link or a smaller KML file.`);
          }
        }
        
        // Parse KML to GeoJSON
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlText, 'text/xml');
        
        // Check for parsing errors
        const parseError = kml.querySelector('parsererror');
        if (parseError) {
          throw new Error('KML parsing error: ' + parseError.textContent);
        }
        
        // Convert KML to GeoJSON (toGeoJSON is from @mapbox/togeojson)
        let geojson;
        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
          geojson = toGeoJSON.kml(kml);
        } else {
          throw new Error('toGeoJSON library not loaded');
        }
        
        // Add to map
        kmlLayer = L.geoJSON(geojson, {
          style: {
            color: '#214025',
            weight: 3,
            opacity: 0.8,
            fillColor: '#214025',
            fillOpacity: 0.1
          }
        }).addTo(zoneMap);
        
        // Fit map to boundary
        if (kmlLayer.getBounds && kmlLayer.getBounds().isValid()) {
          zoneMap.fitBounds(kmlLayer.getBounds(), { padding: [20, 20] });
        }
      } catch (error) {
        console.error('Error loading KML:', error);
        alert('Error loading KML file: ' + error.message);
      }
    }

    // Highlight the selected address marker
    function highlightSelectedMarker(address) {
      if (!zoneMap || !addressMarkers) return;
      
      addressMarkers.forEach(marker => {
        if (marker.address === address) {
          // Highlight selected marker with red icon
          marker.setIcon(L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
          }));
        } else if (selectedAddress && marker.address !== selectedAddress) {
          // Reset other markers to default blue
          marker.setIcon(L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
          }));
        }
      });
    }

    // Update map markers based on filtered addresses
    function updateMapMarkers() {
      if (!sheetData || !sheetData.addressMap) {
        console.log('No sheet data available for map');
        return;
      }
      
      // Make sure map is initialized
      if (!zoneMap) {
        console.log('Map not initialized, initializing now...');
        initializeMap();
        if (!zoneMap) {
          console.error('Failed to initialize map');
          return;
        }
      }
      
      // Clear existing markers
      addressMarkers.forEach(marker => zoneMap.removeLayer(marker));
      addressMarkers = [];
      
      // Get filtered addresses (same logic as displayAddressTable)
      const addresses = Array.from(sheetData.addressMap.keys());
      const contactDateCol = sheetData.headers.find(h => h.toLowerCase().includes('contact') && h.toLowerCase().includes('date'));
      const filteredAddresses = addresses.filter(address => {
        // Street filter
        if (currentStreetFilter !== 'all') {
          const street = extractStreet(address);
          if (street !== currentStreetFilter) return false;
        }
        
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const damage = getAddressDamage(address);
          if (damage !== currentDamageFilter) return false;
        }
        
        // Status filter
        if (currentStatusFilter !== 'all') {
          const status = getAddressStatus(address);
          if (status !== currentStatusFilter) return false;
        }
        
        // Rebuild filter
        const rebuildCol = sheetData.headers.find(h => h.toLowerCase().includes('rebuild'));
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(address);
          if (rows && rows[0]) {
            const rebuildValue = (rows[0][rebuildCol] || '').trim();
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(address);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        
        return true;
      });
      
      // Check for lat/lon columns
      const latCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lat') || lower === 'latitude';
      });
      const lonCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lon') || lower.includes('lng') || lower === 'longitude';
      });
      
      console.log('Looking for coordinates - Lat column:', latCol, 'Lon column:', lonCol);
      console.log('Available headers:', sheetData.headers);
      
      if (!latCol || !lonCol) {
        console.log('Lat/Lon columns not found. Available columns:', sheetData.headers);
        return;
      }
      
      // Add markers for filtered addresses
      const bounds = [];
      let markerCount = 0;
      filteredAddresses.forEach(address => {
        const rows = sheetData.addressMap.get(address);
        if (!rows || rows.length === 0) return;
        
        const firstRow = rows[0];
        let lat, lon;
        
        // Try to get coordinates from lat/lon columns
        const latVal = firstRow[latCol];
        const lonVal = firstRow[lonCol];
        
        if (latVal !== undefined && latVal !== null && latVal !== '' && 
            lonVal !== undefined && lonVal !== null && lonVal !== '') {
          lat = parseFloat(String(latVal).trim());
          lon = parseFloat(String(lonVal).trim());
          if (isNaN(lat) || isNaN(lon)) {
            console.log(`Invalid coordinates for ${address}: lat=${latVal}, lon=${lonVal}`);
            return;
          }
        } else {
          return; // Skip if no coordinates
        }
        
        // Create marker
        try {
          // Use red icon if this is the selected address, blue otherwise
          const isSelected = selectedAddress === address;
          const marker = L.marker([lat, lon], {
            icon: L.icon({
              iconUrl: isSelected 
                ? 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png'
                : 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            })
          }).addTo(zoneMap);
          
          // Build popup content
          let popupContent = `<strong>${address}</strong>`;
          
          // Get resident names and ages
          const nameCol = sheetData.headers.find(h => h.toLowerCase().includes('resident name') || h.toLowerCase().includes('name'));
          const ageCol = sheetData.headers.find(h => h.toLowerCase() === 'age');
          const residents = [];
          rows.forEach(row => {
            if (nameCol && row[nameCol] && row[nameCol].trim()) {
              let residentLine = row[nameCol].trim();
              // Add age if available
              if (ageCol && row[ageCol] && row[ageCol].toString().trim()) {
                residentLine += ', ' + row[ageCol].toString().trim();
              }
              residents.push(residentLine);
            }
          });
          if (residents.length > 0) {
            popupContent += '<br>' + residents.join('<br>');
          }
          
          // Get damage and household status
          const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
          const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
          const info = [];
          if (damageCol && firstRow[damageCol] && firstRow[damageCol].trim()) {
            info.push(firstRow[damageCol].trim());
          }
          if (statusCol && firstRow[statusCol] && firstRow[statusCol].trim()) {
            info.push(firstRow[statusCol].trim());
          }
          if (info.length > 0) {
            popupContent += '<br><small>' + info.join(' â€¢ ') + '</small>';
          }
          
          // Add popup with address, residents, and info
          marker.bindPopup(popupContent);
          
          // Click handler to show address details
          marker.on('click', () => {
            displayAddressDetails(address);
          });
          
          // Store address with marker for highlighting
          marker.address = address;
          
          addressMarkers.push(marker);
          bounds.push([lat, lon]);
          markerCount++;
        } catch (error) {
          console.error(`Error creating marker for ${address}:`, error);
        }
      });
      
      console.log(`Added ${markerCount} markers to map`);
      
      if (markerCount === 0) {
        console.log('No markers created - check that Latitude and Longitude columns have data');
        return;
      }
      
      // Fit map to show all markers (if we have markers and no KML boundary)
      if (bounds.length > 0 && !kmlLayer) {
        zoneMap.fitBounds(bounds, { padding: [20, 20] });
      }
    }

    // Satellite toggle is now handled by Leaflet control (created in initializeMap)

    // KML URL input handler (commented out for now)
    // if (kmlUrlInput) {
    //   kmlUrlInput.addEventListener('keypress', (e) => {
    //     if (e.key === 'Enter') {
    //       if (zoneMap) {
    //         loadKMLBoundary(kmlUrlInput.value.trim());
    //       }
    //     }
    //   });
    // }

    // Update Zone Notes UI
    function updateZoneNotesUI() {
      const zoneNotesText = document.getElementById('zoneNotesText');
      
      console.log('Updating Zone Notes UI, zoneNotes:', zoneNotes);
      
      if (zoneNotesText) {
        zoneNotesText.value = zoneNotes || '';
      } else {
        console.error('Zone Notes UI elements not found');
      }
    }

    // Tab switching functionality
    const addressesTab = document.getElementById('addressesTab');
    const zoneNotesTab = document.getElementById('zoneNotesTab');
    const zoneNotesContent = document.getElementById('zoneNotesContent');

    if (addressesTab && zoneNotesTab) {
      addressesTab.addEventListener('click', () => {
        addressesTab.classList.add('active');
        zoneNotesTab.classList.remove('active');
        if (addressPanelContent) addressPanelContent.style.display = 'block';
        if (zoneNotesContent) zoneNotesContent.style.display = 'none';
      });

      zoneNotesTab.addEventListener('click', () => {
        zoneNotesTab.classList.add('active');
        addressesTab.classList.remove('active');
        if (addressPanelContent) addressPanelContent.style.display = 'none';
        if (zoneNotesContent) zoneNotesContent.style.display = 'flex';
      });
    }

    // Save Zone Notes to Metadata sheet
    async function saveZoneNotes() {
      if (!metadataSheetId || !accessToken) {
        alert('Please sign in to save notes.');
        return;
      }

      const zoneNotesText = document.getElementById('zoneNotesText');
      const saveStatus = document.getElementById('zoneNotesStatus');
      const saveBtn = document.getElementById('saveZoneNotesBtn');
      
      if (!zoneNotesText) return;
      
      const newNotes = zoneNotesText.value.trim();
      saveBtn.disabled = true;
      saveStatus.textContent = 'Saving...';
      saveStatus.className = 'save-status-small';

      try {
        // First, try to read existing metadata to preserve KML URL
        let kmlUrlValue = zoneKmlUrl;
        try {
          const existingMetadata = await fetchMetadata(metadataSheetId);
          if (existingMetadata && existingMetadata.kmlUrl) {
            kmlUrlValue = existingMetadata.kmlUrl;
          }
        } catch (e) {
          // If Zone Notes sheet doesn't exist, we'll create it
        }

        // Prepare the metadata rows
        const values = [
          ['Zone Notes', newNotes],
          ['KML URL', kmlUrlValue || '']
        ];

        // Use batchUpdate to write to Zone Notes sheet
        const response = await fetch(
          `https://sheets.googleapis.com/v4/spreadsheets/${metadataSheetId}/values/Zone Notes!A1:B2?valueInputOption=USER_ENTERED`,
          {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              values: values
            })
          }
        );

        if (!response.ok) {
          // If Zone Notes sheet doesn't exist, try to create it first
          // For now, just show error - user can create the sheet manually
          throw new Error('Zone Notes sheet not found. Please create a sheet named "Zone Notes" with columns A (key) and B (value).');
        }

        zoneNotes = newNotes;
        saveStatus.textContent = 'Saved!';
        saveStatus.className = 'save-status-small saved';
        
        setTimeout(() => {
          saveStatus.textContent = '';
        }, 2000);

      } catch (error) {
        console.error('Save error:', error);
        saveStatus.textContent = `Error: ${error.message}`;
        saveStatus.className = 'save-status-small error';
      } finally {
        saveBtn.disabled = false;
      }
    }

    // Zone Notes save button handler
    const saveZoneNotesBtn = document.getElementById('saveZoneNotesBtn');
    if (saveZoneNotesBtn) {
      saveZoneNotesBtn.addEventListener('click', saveZoneNotes);
    }

    // Contact Mode toggle
    let contactModeActive = false;
    window.contactModeActive = false;
    const contactModeBtn = document.getElementById('contactModeBtn');
    if (contactModeBtn) {
      contactModeBtn.addEventListener('click', () => {
        contactModeActive = !contactModeActive;
        window.contactModeActive = contactModeActive;
        contactModeBtn.classList.toggle('active', contactModeActive);
        
        // If we're viewing an address detail, refresh it to show/hide contact mode UI
        const addressDetails = document.querySelector('.address-details.active');
        if (addressDetails) {
          const addressHeading = addressDetails.querySelector('h3');
          if (addressHeading) {
            const address = addressHeading.textContent.trim();
            displayAddressDetails(address);
          }
        }
      });
    }

    // Mark contact function
    window.markContact = async function(button, address, originalRowIndex, contactColumn) {
      if (!accessToken) {
        alert('Please sign in to mark contacts.');
        return;
      }

      // Get the current sheet URL - try multiple sources
      let sheetUrl = currentSheetUrl;
      if (!sheetUrl) {
        sheetUrl = localStorage.getItem('savedSheetUrl') || '';
      }
      if (!sheetUrl) {
        alert('No sheet loaded. Please load a spreadsheet first.');
        return;
      }

      const today = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      });

      try {
        const sheetInfo = extractSheetId(sheetUrl);
        if (!sheetInfo || !sheetInfo.sheetId) {
          console.error('Sheet URL:', sheetUrl);
          console.error('Sheet Info:', sheetInfo);
          throw new Error('Invalid sheet URL. Make sure a spreadsheet is loaded.');
        }

        // Find the row to update (using originalRowIndex + 2 because row 1 is header, row 2 is first data)
        const rowNumber = originalRowIndex + 2;

        // Get column letters for contact date and contact notes
        const headers = sheetData.headers;
        const contactColIndex = headers.findIndex(h => 
          h.toLowerCase() === 'last contact date' ||
          h.toLowerCase().includes('last contact') || 
          h.toLowerCase().includes('contact date') ||
          h.toLowerCase().includes('contacted')
        );
        
        const contactNotesColIndex = headers.findIndex(h => 
          h.toLowerCase() === 'contact notes' ||
          h.toLowerCase().includes('contact notes')
        );

        console.log('Contact Notes column search:', {
          headers: headers,
          contactNotesColIndex: contactNotesColIndex,
          foundColumn: contactNotesColIndex >= 0 ? headers[contactNotesColIndex] : 'NOT FOUND'
        });

        // Get contact notes from the textarea
        const contactNotesTextarea = button.parentNode.querySelector('.contact-notes-quick');
        const contactNotes = contactNotesTextarea ? contactNotesTextarea.value.trim() : '';

        console.log('Contact notes from textarea:', contactNotes);

        // Prepare updates for both date and notes
        const updates = [];
        
        // Update Last Contact Date
        if (contactColIndex >= 0) {
          const columnLetter = indexToColumnLetter(contactColIndex);
          const sheetName = 'Sheet1';
          const cellRange = `${sheetName}!${columnLetter}${rowNumber}`;
          updates.push({
            range: cellRange,
            values: [[today]]
          });
          console.log('Adding Last Contact Date update:', cellRange, today);
        }

        // Update Contact Notes if column exists (save even if empty to allow clearing)
        if (contactNotesColIndex >= 0) {
          const notesColumnLetter = indexToColumnLetter(contactNotesColIndex);
          const sheetName = 'Sheet1';
          const notesCellRange = `${sheetName}!${notesColumnLetter}${rowNumber}`;
          updates.push({
            range: notesCellRange,
            values: [[contactNotes]]
          });
          console.log('Adding Contact Notes update:', notesCellRange, contactNotes);
        } else {
          console.warn('Contact Notes column not found in headers:', headers);
        }

        // Save both updates using batchUpdate
        if (updates.length > 0) {
          console.log('Sending batch update with', updates.length, 'updates:', updates);
          const response = await fetch(
            `https://sheets.googleapis.com/v4/spreadsheets/${sheetInfo.sheetId}/values:batchUpdate`,
            {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                valueInputOption: 'USER_ENTERED',
                data: updates
              })
            }
          );

          if (!response.ok) {
            const error = await response.json();
            console.error('Batch update error:', error);
            throw new Error(error.error?.message || 'Failed to save contact');
          }
          
          const result = await response.json();
          console.log('Batch update successful:', result);
        } else {
          console.warn('No updates to save');
        }

        // Update UI
        button.classList.add('contacted');
        button.textContent = 'âœ“ Contacted';
        
        // Add date display if it doesn't exist
        const existingDate = button.parentNode.querySelector('.contact-date');
        if (!existingDate) {
          const dateDiv = document.createElement('div');
          dateDiv.className = 'contact-date';
          dateDiv.textContent = `Last contact: ${today}`;
          button.parentNode.insertBefore(dateDiv, button.nextSibling);
        } else {
          existingDate.textContent = `Last contact: ${today}`;
        }

        // Update local data
        if (sheetData && sheetData.data && sheetData.data[originalRowIndex]) {
          const contactCol = headers.find(h => 
            h.toLowerCase() === 'last contact date' ||
            h.toLowerCase().includes('last contact') || 
            h.toLowerCase().includes('contact date') ||
            h.toLowerCase().includes('contacted')
          ) || contactColumn;
          sheetData.data[originalRowIndex][contactCol] = today;
          
          // Update contact notes in local data if column exists
          if (contactNotesColIndex >= 0 && contactNotes) {
            const contactNotesCol = headers[contactNotesColIndex];
            sheetData.data[originalRowIndex][contactNotesCol] = contactNotes;
          }
          
          // Update address map
          if (sheetData.addressMap && sheetData.addressMap.has(address)) {
            const rows = sheetData.addressMap.get(address);
            const row = rows.find(r => r.__originalIndex === originalRowIndex);
            if (row) {
              row[contactCol] = today;
              if (contactNotesColIndex >= 0 && contactNotes) {
                const contactNotesCol = headers[contactNotesColIndex];
                row[contactNotesCol] = contactNotes;
              }
            }
          }
        }

        // Update person entry styling
        const personEntry = button.closest('.person-entry');
        if (personEntry) {
          personEntry.classList.remove('no-contact');
          personEntry.classList.add('recent-contact');
        }

      } catch (error) {
        console.error('Error marking contact:', error);
        alert('Error saving contact: ' + error.message);
      }
    };


    // Chart instances
    let peopleContactChart = null;
    let householdsContactChart = null;
    let damageChart = null;
    let householdStatusChart = null;

    // Update Zone Progress Charts
    function updateZoneProgressCharts() {
      if (!sheetData || !sheetData.data || sheetData.data.length === 0) {
        return;
      }

      // Charts are now in the progress view, not a separate panel
      // The view will be shown/hidden by the navigation system

      const headers = sheetData.headers;
      const data = sheetData.data;

      // Find relevant columns
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));

      // 1. People Contacted Chart
      let peopleContacted = 0;
      let peopleNotContacted = 0;
      data.forEach(row => {
        const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
        if (hasContact) {
          peopleContacted++;
        } else {
          peopleNotContacted++;
        }
      });

      const peopleTotal = peopleContacted + peopleNotContacted;
      const peopleContactedPct = peopleTotal > 0 ? ((peopleContacted / peopleTotal) * 100).toFixed(1) : '0';
      const peopleNotContactedPct = peopleTotal > 0 ? ((peopleNotContacted / peopleTotal) * 100).toFixed(1) : '0';

      const peopleContactCtx = document.getElementById('peopleContactChart');
      if (peopleContactChart) peopleContactChart.destroy();
      if (peopleContactCtx) {
        peopleContactChart = new Chart(peopleContactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${peopleContactedPct}%)`, `Not Contacted (${peopleNotContactedPct}%)`],
            datasets: [{
              data: [peopleContacted, peopleNotContacted],
              backgroundColor: ['#4caf50', '#ff9800'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 2. Households Contacted Chart
      const households = new Set();
      const householdsContacted = new Set();
      const houseNumCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'House #' || lower === 'house #' || lower.includes('house #') || 
               lower.includes('house#') || lower === 'house number' || lower === 'house num' ||
               (lower === 'house' && !lower.includes('hold'));
      });
      const streetCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'Street' || lower === 'street' || (lower.includes('street') && !lower.includes('address'));
      });

      data.forEach(row => {
        const houseNum = houseNumCol ? (row[houseNumCol] || '').trim() : '';
        const street = streetCol ? (row[streetCol] || '').trim() : '';
        const address = houseNum && street ? `${houseNum} ${street}` : '';
        if (address) {
          households.add(address);
          const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
          if (hasContact) {
            householdsContacted.add(address);
          }
        }
      });

      const householdsContactedCount = householdsContacted.size;
      const householdsNotContactedCount = households.size - householdsContactedCount;
      const householdsTotal = householdsContactedCount + householdsNotContactedCount;
      const householdsContactedPct = householdsTotal > 0 ? ((householdsContactedCount / householdsTotal) * 100).toFixed(1) : '0';
      const householdsNotContactedPct = householdsTotal > 0 ? ((householdsNotContactedCount / householdsTotal) * 100).toFixed(1) : '0';

      const householdsContactCtx = document.getElementById('householdsContactChart');
      if (householdsContactChart) householdsContactChart.destroy();
      if (householdsContactCtx) {
        householdsContactChart = new Chart(householdsContactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${householdsContactedPct}%)`, `Not Contacted (${householdsNotContactedPct}%)`],
            datasets: [{
              data: [householdsContactedCount, householdsNotContactedCount],
              backgroundColor: ['#4caf50', '#ff9800'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 3. Damage Chart
      const damageCounts = {};
      let damageUnknown = 0;
      if (damageCol) {
        data.forEach(row => {
          const damage = row[damageCol] ? String(row[damageCol]).trim() : '';
          if (damage) {
            damageCounts[damage] = (damageCounts[damage] || 0) + 1;
          } else {
            damageUnknown++;
          }
        });
      } else {
        // If no damage column, all are unknown
        damageUnknown = data.length;
      }

      const damageLabels = Object.keys(damageCounts);
      const damageData = Object.values(damageCounts);
      const damageTotal = damageData.reduce((a, b) => a + b, 0) + damageUnknown;
      
      // Add Unknown if there are any
      if (damageUnknown > 0) {
        damageLabels.push('Unknown');
        damageData.push(damageUnknown);
      }
      
      // Calculate percentages for labels
      const damageLabelsWithPct = damageLabels.map((label, index) => {
        const value = damageData[index];
        const pct = damageTotal > 0 ? ((value / damageTotal) * 100).toFixed(1) : '0';
        return `${label} (${pct}%)`;
      });
      
      const damageColors = ['#f44336', '#ff9800', '#4caf50', '#2196f3', '#9c27b0', '#00bcd4', '#9e9e9e'];

      const damageCtx = document.getElementById('damageChart');
      if (damageChart) damageChart.destroy();
      if (damageCtx && (damageLabels.length > 0 || damageUnknown > 0)) {
        damageChart = new Chart(damageCtx, {
          type: 'pie',
          data: {
            labels: damageLabelsWithPct,
            datasets: [{
              data: damageData,
              backgroundColor: damageColors.slice(0, damageLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Remove percentage from label for tooltip (it's already in the label)
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 4. Household Status Chart
      const statusCounts = {};
      let statusUnknown = 0;
      if (statusCol) {
        data.forEach(row => {
          const status = row[statusCol] ? String(row[statusCol]).trim() : '';
          if (status) {
            statusCounts[status] = (statusCounts[status] || 0) + 1;
          } else {
            statusUnknown++;
          }
        });
      } else {
        // If no status column, all are unknown
        statusUnknown = data.length;
      }

      const statusLabels = Object.keys(statusCounts);
      const statusData = Object.values(statusCounts);
      const statusTotal = statusData.reduce((a, b) => a + b, 0) + statusUnknown;
      
      // Add Unknown if there are any
      if (statusUnknown > 0) {
        statusLabels.push('Unknown');
        statusData.push(statusUnknown);
      }
      
      // Calculate percentages for labels
      const statusLabelsWithPct = statusLabels.map((label, index) => {
        const value = statusData[index];
        const pct = statusTotal > 0 ? ((value / statusTotal) * 100).toFixed(1) : '0';
        return `${label} (${pct}%)`;
      });
      
      const statusColors = ['#2196f3', '#4caf50', '#ff9800', '#9c27b0', '#00bcd4', '#f44336', '#9e9e9e'];

      const statusCtx = document.getElementById('householdStatusChart');
      if (householdStatusChart) householdStatusChart.destroy();
      if (statusCtx && (statusLabels.length > 0 || statusUnknown > 0)) {
        householdStatusChart = new Chart(statusCtx, {
          type: 'pie',
          data: {
            labels: statusLabelsWithPct,
            datasets: [{
              data: statusData,
              backgroundColor: statusColors.slice(0, statusLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Remove percentage from label for tooltip (it's already in the label)
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
    }

    // Make displayAddressList available globally for back button
    window.displayAddressList = displayAddressList;
  </script>
</body>
</html>
