<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Altagether NC Dashboard Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-kml@1.0.0/dist/leaflet-kml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --mint: #8EBB8C;
      --sprout: #B5E593;
      --sunbeam: #FDF9CE;
      --honey: #E8C694;
      --clementine: #F95738;
      --plum: #6A057F;
      --sky: #B3E0F5;
      --river: #3A6EA5;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: var(--sky);
      color: #143039;
    }

    .shell {
      max-width: 1280px;
      margin: 0 auto;
      padding: 16px;
    }

    .nav {
      background: var(--river);
      color: #fff;
      padding: 12px 20px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 3px 10px rgba(0,0,0,0.1);
      margin-bottom: 16px;
    }

    .nav-title { 
      font-weight: 600; 
      font-size: 1.5rem;
    }
    .nav-pill {
      background: var(--mint);
      color: #143039;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
    }

    .main { display: flex; gap: 16px; margin-bottom: 16px; align-items: stretch; }

    /* Column layout */
    .col-left { flex: 2; display: flex; flex-direction: column; gap: 16px; }
    .col-right { flex: 1; display: flex; flex-direction: column; gap: 16px; align-items: stretch; }

    .card {
      background: var(--sunbeam);
      border-radius: 10px;
      padding: 12px 14px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.06);
      border: 1px solid rgba(0,0,0,0.05);
    }

    .card-header {
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }

    .badge {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--sprout);
      color: #214025;
    }

    .map-card {
      min-height: 500px;
      height: 500px;
      background: var(--mint);
      position: relative;
      overflow: hidden;
    }

    .map-iframe {
      width: 100%;
      height: 100%;
      border: 0;
    }

    .map-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 500;
      color: rgba(0,0,0,0.5);
    }

    #zoneMap {
      width: 100%;
      height: calc(100% - 80px);
      border-radius: 0 0 8px 8px;
      z-index: 0;
    }

    .map-kml-input {
      margin: 0 8px 8px 8px;
      padding: 6px 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.85rem;
      width: calc(100% - 32px);
    }

    .map-toggle-btn {
      margin-left: auto;
      padding: 4px 8px;
      background: rgba(255,255,255,0.8);
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }

    .map-toggle-btn:hover {
      background: rgba(255,255,255,1);
    }

    /* Spreadsheet panel now full-width below the map */
    .sheet-panel {
      background: #ffffff;
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.06);
    }

    .sheet-input-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .sheet-input {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.9rem;
    }


    .btn-load {
      padding: 6px 12px;
      background: var(--clementine);
      color: white;
      border: 0;
      border-radius: 999px;
      cursor: pointer;
    }

    .sheet-iframe {
      width: 100%;
      height: 480px; /* MUCH bigger now */
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 8px;
    }

    /* Zone Progress panel */
    .zone-progress-panel {
      width: 100%;
      margin-top: 16px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }

    .zone-progress-panel h3 {
      margin: 0 0 20px 0;
      color: var(--river);
      font-size: 1.2rem;
      border-bottom: 2px solid var(--river);
      padding-bottom: 8px;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 24px;
      margin-top: 20px;
    }

    .chart-container {
      position: relative;
      height: 280px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 8px;
      padding: 16px;
      padding-bottom: 40px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
    }

    .chart-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--river);
      margin-bottom: 12px;
      text-align: center;
    }

    .zone-notes-card {
      background: #ffffff;
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.06);
      margin-bottom: 16px;
    }

    .zone-notes-text {
      width: 100%;
      flex: 1;
      min-height: 300px;
      padding: 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .btn-save-small {
      padding: 4px 8px;
      background: var(--clementine);
      color: white;
      border: 0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-left: auto;
    }

    .btn-save-small:hover {
      background: #e0452a;
    }

    .save-status-small {
      margin-top: 4px;
      font-size: 0.8rem;
      min-height: 16px;
    }

    .save-status-small.saved {
      color: #214025;
    }

    .save-status-small.error {
      color: var(--clementine);
    }

    /* Address panel matches left column height (map 500px + gap 16px + link boxes ~140px) */
    .address-panel {
      height: 656px; /* Taller to align with bottom of Support Pathways */
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .address-panel .card-header {
      padding: 0;
      margin: 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .address-panel-tabs {
      display: flex;
      gap: 0;
      margin: 0;
      padding: 0;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      align-items: stretch;
      border-bottom: 2px solid rgba(0, 0, 0, 0.1);
      background: rgba(255, 255, 255, 0.5);
    }

    .tab-btn {
      padding: 12px 24px;
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      color: rgba(0, 0, 0, 0.5);
      transition: all 0.2s ease;
      position: relative;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .tab-btn:hover {
      color: rgba(0, 0, 0, 0.7);
      background: rgba(0, 0, 0, 0.02);
    }

    .tab-btn.active {
      color: var(--river);
      border-bottom-color: var(--river);
      background: transparent;
      font-weight: 600;
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--river);
    }

    .btn-contact-mode {
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.15);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--river);
      transition: all 0.2s;
    }

    .btn-contact-mode:hover {
      background: rgba(255, 255, 255, 1);
      border-color: var(--river);
    }

    .btn-contact-mode.active {
      background: var(--river);
      color: white;
      border-color: var(--river);
    }

    .contact-mode-indicator {
      display: inline-block;
      padding: 2px 8px;
      background: rgba(255, 200, 0, 0.2);
      border: 1px solid rgba(255, 200, 0, 0.5);
      border-radius: 4px;
      font-size: 0.75rem;
      color: #856404;
      margin-left: 8px;
    }

    .contact-button {
      padding: 6px 12px;
      background: var(--mint);
      border: 1px solid var(--river);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--river);
      transition: all 0.2s;
      margin-top: 8px;
    }

    .contact-button:hover {
      background: rgba(212, 232, 215, 0.8);
    }

    .contact-button.contacted {
      background: rgba(212, 232, 215, 0.5);
      color: #666;
      border-color: #999;
    }

    .contact-button.contacted:hover {
      background: rgba(212, 232, 215, 0.7);
    }

    .contact-date {
      font-size: 0.8rem;
      color: #666;
      margin-top: 4px;
      font-style: italic;
    }

    .contact-notes-quick {
      width: 100%;
      margin-top: 8px;
      padding: 6px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 4px;
      font-size: 0.85rem;
      font-family: inherit;
      resize: vertical;
      min-height: 60px;
    }

    .person-entry.no-contact {
      border-left-color: #ff9800;
      background: rgba(255, 152, 0, 0.05);
    }

    .person-entry.recent-contact {
      border-left-color: #4caf50;
    }

    .zone-notes-content {
      padding: 12px;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .zone-notes-text {
      width: 100%;
      flex: 1;
      min-height: 300px;
      padding: 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .address-panel-content {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
    }

    .address-filters {
      margin-bottom: 12px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .address-filters select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      background: white;
      cursor: pointer;
    }

    .address-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .address-item {
      padding: 8px 10px;
      margin-bottom: 6px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .address-item:hover {
      background: rgba(255, 255, 255, 0.9);
      border-color: var(--river);
      transform: translateX(2px);
    }

    .address-item.active {
      background: var(--river);
      color: white;
      border-color: var(--river);
    }

    .address-details {
      display: none;
    }

    .address-details.active {
      display: block;
    }

    .address-details h3 {
      margin: 0 0 12px 0;
      font-size: 1.1rem;
      color: var(--river);
      border-bottom: 2px solid var(--river);
      padding-bottom: 6px;
    }

    .person-entry {
      background: rgba(255, 255, 255, 0.7);
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 6px;
      border-left: 3px solid var(--mint);
    }

    .person-name {
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--plum);
    }

    .person-info {
      font-size: 0.9rem;
      color: #143039;
      margin: 4px 0;
    }

    .person-info strong {
      color: var(--river);
    }

    .loading, .error, .empty {
      padding: 20px;
      text-align: center;
      color: rgba(0, 0, 0, 0.6);
    }

    .error {
      color: var(--clementine);
    }

    .btn-refresh {
      padding: 4px 10px;
      background: var(--mint);
      color: #143039;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-left: 8px;
      transition: transform 0.2s;
    }

    .btn-refresh:hover {
      transform: rotate(90deg);
    }

    .btn-refresh.active {
      background: var(--clementine);
      color: white;
    }

    .btn-back {
      padding: 6px 12px;
      background: var(--river);
      color: white;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-bottom: 12px;
    }

    .btn-signin {
      padding: 8px 16px;
      background: #4285f4;
      color: white;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin: 10px 0;
    }

    .btn-signin:hover {
      background: #357ae8;
    }

    .btn-save {
      padding: 6px 12px;
      background: var(--mint);
      color: #143039;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-top: 8px;
    }

    .btn-save:hover {
      background: var(--sprout);
    }

    .btn-save:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .signin-prompt {
      background: rgba(255, 255, 255, 0.8);
      padding: 16px;
      border-radius: 8px;
      text-align: center;
      margin: 10px 0;
      border: 2px dashed var(--river);
    }

    .signin-prompt p {
      margin: 0 0 12px 0;
      color: #143039;
      font-size: 0.9rem;
    }

    .editable-field {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--mint);
      border-radius: 4px;
      padding: 6px 8px;
      min-height: 20px;
      cursor: text;
      transition: all 0.2s;
    }

    .editable-field:focus {
      outline: none;
      border-color: var(--river);
      background: white;
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.2);
    }

    .editable-field:empty:before {
      content: "Click to add notes...";
      color: rgba(0, 0, 0, 0.4);
    }

    /* Expandable notes textarea */
    .editable-notes {
      width: 100%;
      background: #ffffff;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      padding: 8px;
      min-height: 60px;
      font-family: inherit;
      font-size: 0.9rem;
      resize: vertical;
      cursor: text;
      transition: all 0.2s;
      box-sizing: border-box;
    }

    .editable-notes:focus {
      outline: none;
      border-color: var(--river);
      box-shadow: 0 0 0 2px rgba(33, 64, 37, 0.1);
    }

    .editable-notes::placeholder {
      color: rgba(0, 0, 0, 0.4);
    }

    /* Subtle editable field for non-notes */
    .editable-inline {
      display: inline-block;
      background: rgba(255, 255, 255, 0.4);
      border: 1px dashed rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      padding: 2px 6px;
      min-width: 60px;
      cursor: text;
      transition: all 0.2s;
    }

    .editable-inline:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: var(--mint);
    }

    .editable-inline:focus {
      outline: none;
      background: white;
      border: 1px solid var(--river);
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .editable-inline:empty:before {
      content: "...";
      color: rgba(0, 0, 0, 0.3);
    }

    /* Custom marker styling */
    .custom-marker {
      background: transparent !important;
      border: none !important;
    }

    /* Dropdown for Damage and Household Status */
    .editable-dropdown {
      display: inline-block;
      background: rgba(255, 255, 255, 0.4);
      border: 1px dashed rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      padding: 2px 6px;
      min-width: 100px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: inherit;
      font-family: inherit;
      color: inherit;
    }

    .editable-dropdown:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: var(--mint);
    }

    .editable-dropdown:focus {
      outline: none;
      background: white;
      border: 1px solid var(--river);
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .save-status {
      font-size: 0.8rem;
      margin-top: 6px;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
    }

    .save-status.saving {
      background: var(--sunbeam);
      color: #143039;
    }

    .save-status.saved {
      background: var(--mint);
      color: #214025;
    }

    .save-status.error {
      background: var(--clementine);
      color: white;
    }

    .bottom-row {
      display: flex;
      gap: 16px;
    }

    .bottom-card { flex: 1; }
    .bottom-card:nth-child(1) { background: var(--honey); }
    .bottom-card:nth-child(2) { background: var(--sunbeam); }
    .bottom-card:nth-child(3) { background: var(--mint); }

    .link-list {
      margin: 6px 0 0;
      padding-left: 0;
      list-style: none;
      font-size: 0.9rem;
    }

    .link-list li { margin-bottom: 4px; }
    .link-list a { color: var(--river); text-decoration: none; }

    @media (max-width: 900px) {
      .main { flex-direction: column; }
      .bottom-row { flex-direction: column; }
    }
  </style>
</head>

<body>
  <div class="shell">

    <header class="nav">
      <div class="nav-title" id="navTitle">Altagether Zone Dashboard</div>
      <div class="nav-pill">Prototype</div>
    </header>

    <main class="main">
      <!-- LEFT COLUMN -->
      <section class="col-left">

        <!-- MAP -->
        <div class="card map-card">
          <div class="card-header">
            <span>Zone Map</span>
            <span class="badge">Interactive</span>
            <button id="mapToggleBtn" class="map-toggle-btn" title="Toggle satellite view">üõ∞Ô∏è</button>
          </div>
          <!-- <input type="text" id="kmlUrlInput" class="map-kml-input" placeholder="Optional: Paste KML file URL for zone boundary" /> -->
          <div id="zoneMap"></div>
        </div>

        <!-- BOTTOM LINKS -->
        <div class="bottom-row">
          <div class="card bottom-card">
            <div class="card-header"><span>Altagether Links</span></div>
            <ul class="link-list">
              <li><a href="#">NC Calendar</a></li>
              <li><a href="#">Community Agreements</a></li>
            </ul>
          </div>

          <div class="card bottom-card">
            <div class="card-header"><span>News Links</span></div>
            <ul class="link-list">
              <li><a href="#">Fire Recovery News</a></li>
              <li><a href="#">County Updates</a></li>
            </ul>
          </div>

          <div class="card bottom-card">
            <div class="card-header"><span>Support Pathways</span></div>
            <ul class="link-list">
              <li><a href="#">Disaster Case Mgmt</a></li>
              <li><a href="#">Legal Aid</a></li>
            </ul>
          </div>
        </div>
      </section>

      <!-- RIGHT COLUMN -->
      <section class="col-right">
        <div class="card address-panel">
          <div class="address-panel-tabs">
            <button class="tab-btn active" id="addressesTab" data-tab="addresses">Addresses</button>
            <button class="tab-btn" id="zoneNotesTab" data-tab="notes">Zone Notes</button>
            <div style="margin-left: auto; padding: 8px 12px; display: flex; gap: 8px; align-items: center;">
              <button class="btn-contact-mode" id="contactModeBtn" title="Toggle contact tracking mode">üìû Contact Mode</button>
              <button class="btn-refresh" id="refreshAddressesBtn" title="Refresh addresses now">‚Üª</button>
            </div>
          </div>
          <div style="height: 48px; flex-shrink: 0;">
            <!-- Spacer for tabs -->
          </div>
          <div class="address-panel-content" id="addressPanelContent">
            <div class="empty">Load a spreadsheet to see addresses</div>
          </div>
          <div class="zone-notes-content" id="zoneNotesContent" style="display: none;">
            <textarea id="zoneNotesText" class="zone-notes-text" placeholder="Zone-level notes appear here..."></textarea>
            <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center;">
              <div class="save-status-small" id="zoneNotesStatus"></div>
              <button class="btn-save-small" id="saveZoneNotesBtn" title="Save notes">üíæ Save</button>
            </div>
          </div>
          <div id="signinPrompt" style="display: none;" class="signin-prompt">
            <p><strong>Sign in to edit</strong><br>Click below to sign in with Google and enable editing</p>
            <button class="btn-signin" id="signInBtn">
              <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
              Sign in with Google
            </button>
          </div>
        </div>
      </section>
    </main>

    <!-- SPREADSHEET (full width below main content) -->
    <div class="card sheet-panel">
      <div class="card-header">
        <span>Your Zone Spreadsheet</span>
      </div>
      <div class="sheet-input-row">
        <input id="sheetUrlInput" class="sheet-input" placeholder="Paste Google Sheet /edit link" />
        <button class="btn-load" id="loadSheetBtn">Load</button>
      </div>
      <iframe id="sheetFrame" class="sheet-iframe"></iframe>
    </div>

    <!-- ZONE PROGRESS PANEL -->
    <div class="zone-progress-panel" id="zoneProgressPanel" style="display: none;">
      <h3>Zone Progress</h3>
      <div class="charts-grid" id="chartsGrid">
        <div class="chart-container">
          <div class="chart-title">People Contacted</div>
          <canvas id="peopleContactChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">Households Contacted</div>
          <canvas id="householdsContactChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">Damage Status</div>
          <canvas id="damageChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">Household Status</div>
          <canvas id="householdStatusChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    const input = document.getElementById("sheetUrlInput");
    const frame = document.getElementById("sheetFrame");
    const btn = document.getElementById("loadSheetBtn");
    const refreshBtn = document.getElementById("refreshAddressesBtn");
    const addressPanelContent = document.getElementById("addressPanelContent");
    const signInBtn = document.getElementById("signInBtn");
    const signinPrompt = document.getElementById("signinPrompt");
    // const kmlUrlInput = document.getElementById("kmlUrlInput"); // Commented out - KML input hidden for now

    let currentSheetUrl = '';
    let sheetData = [];
    let selectedAddress = null; // Track currently selected address
    let savedScrollPosition = 0; // Track scroll position for refresh
    let accessToken = null; // OAuth2 access token
    let currentSheetId = null; // Current sheet ID for writing
    let currentStreetFilter = 'all'; // Current street filter
    let currentDamageFilter = 'all'; // Current damage filter
    let currentStatusFilter = 'all'; // Current household status filter
    let zoneMap = null; // Leaflet map instance
    let addressMarkers = []; // Array of address markers
    let kmlLayer = null; // KML boundary layer
    let currentTileLayer = null; // Current map tile layer
    let isSatelliteMode = false; // Track satellite mode state
    let zoneNotes = ''; // Zone-level notes
    let zoneKmlUrl = ''; // Zone KML URL from metadata
    let metadataSheetId = null; // Sheet ID for metadata sheet

    // Load OAuth token from localStorage
    const savedToken = localStorage.getItem('googleOAuthToken');
    const savedTokenExpiry = localStorage.getItem('googleOAuthTokenExpiry');
    if (savedToken && savedTokenExpiry && Date.now() < parseInt(savedTokenExpiry)) {
      accessToken = savedToken;
      updateSignInUI();
    }

    // Load saved sheet URL from localStorage
    const savedSheetUrl = localStorage.getItem('savedSheetUrl');
    if (savedSheetUrl && input) {
      input.value = savedSheetUrl;
      currentSheetUrl = savedSheetUrl;
      // Auto-load the sheet if user is signed in (wait a bit for OAuth to initialize)
      if (accessToken) {
        setTimeout(() => {
          if (currentSheetUrl) {
            frame.src = currentSheetUrl;
            loadAddressData(currentSheetUrl);
          }
        }, 1000);
      }
    }

    // Initialize Google API
    function initGoogleAPI() {
      gapi.load('client', () => {
        gapi.client.init({
          apiKey: savedApiKey || '',
          discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
        }).then(() => {
          console.log('Google API initialized');
        });
      });
    }

    // Initialize on page load
    if (typeof gapi !== 'undefined') {
      initGoogleAPI();
    } else {
      window.addEventListener('load', () => {
        if (typeof gapi !== 'undefined') {
          initGoogleAPI();
        }
      });
    }

    // ============================================
    // CONFIGURATION: OAuth Client ID
    // ============================================
    // To enable editing, you need a Google OAuth Client ID:
    // 1. Go to https://console.cloud.google.com/apis/credentials
    // 2. Create OAuth 2.0 Client ID (Web application)
    // 3. Add your domain to authorized JavaScript origins
    // 4. Replace 'YOUR_CLIENT_ID' below with your actual Client ID
    // ============================================
    const OAUTH_CLIENT_ID = '633926045450-3214il5eg7emu5e0fp8am1g26jdfnoh7.apps.googleusercontent.com'; // Replace with your OAuth Client ID

    // OAuth2 Sign In
    async function signIn() {
      if (OAUTH_CLIENT_ID === 'YOUR_CLIENT_ID') {
        alert('OAuth Client ID not configured. Please set OAUTH_CLIENT_ID in the code.');
        return;
      }
      
      try {
        const tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: OAUTH_CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/spreadsheets',
          callback: (response) => {
            if (response.error) {
              console.error('Sign in error:', response.error);
              alert('Sign in failed. Please try again.');
              return;
            }
            accessToken = response.access_token;
            // Store token with expiry (tokens last 1 hour, store for 50 minutes)
            const expiry = Date.now() + (50 * 60 * 1000);
            localStorage.setItem('googleOAuthToken', accessToken);
            localStorage.setItem('googleOAuthTokenExpiry', expiry.toString());
            updateSignInUI();
            // Refresh current address if one is selected
            if (selectedAddress && currentSheetUrl) {
              loadAddressData(currentSheetUrl);
            }
          },
        });
        tokenClient.requestAccessToken({ prompt: 'consent' });
      } catch (error) {
        console.error('Sign in error:', error);
        alert('Error signing in. Please try again.');
      }
    }

    // Sign Out
    function signOut() {
      accessToken = null;
      localStorage.removeItem('googleOAuthToken');
      localStorage.removeItem('googleOAuthTokenExpiry');
      updateSignInUI();
      if (selectedAddress && currentSheetUrl) {
        loadAddressData(currentSheetUrl);
      }
    }

    // Update sign-in UI
    function updateSignInUI() {
      if (accessToken) {
        signinPrompt.style.display = 'none';
        // Could add a sign-out button here if needed
      } else {
        // Always show sign-in prompt when not signed in
        signinPrompt.style.display = 'block';
      }
    }

    // Sign in button handler
    signInBtn.addEventListener('click', signIn);

    // Extract sheet ID from any Google Sheets URL format
    function extractSheetId(sheetUrl) {
      // Handle published format: /spreadsheets/d/e/...
      const publishedMatch = sheetUrl.match(/\/spreadsheets\/d\/e\/([a-zA-Z0-9-_]+)/);
      if (publishedMatch) {
        return { sheetId: publishedMatch[1], isPublished: true };
      }
      
      // Handle standard format: /spreadsheets/d/...
      const standardMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
      if (!standardMatch) {
        return null;
      }
      
      return { sheetId: standardMatch[1], isPublished: false };
    }

    // Convert Google Sheets URL to CSV export URL
    function getCsvUrl(sheetUrl) {
      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        console.error('Could not parse Google Sheets URL:', sheetUrl);
        return null;
      }
      
      if (sheetInfo.isPublished) {
        // For published sheets, use /pub?output=csv
        const csvUrl = `https://docs.google.com/spreadsheets/d/e/${sheetInfo.sheetId}/pub?output=csv`;
        console.log('Converted published URL to CSV:', csvUrl);
        return csvUrl;
      }
      
      // For standard format, extract GID if present
      const gidMatch = sheetUrl.match(/[#&]gid=(\d+)/);
      const gid = gidMatch ? gidMatch[1] : '0';
      
      // Build CSV export URL
      const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetInfo.sheetId}/export?format=csv&gid=${gid}`;
      console.log('Converted standard URL to CSV:', csvUrl);
      return csvUrl;
    }

    // Fetch data using Google Sheets API v4 with OAuth token
    async function fetchViaOAuth(sheetId, range = 'A1:ZZ1000', sheetName = null) {
      // Check if token is expired and refresh if needed
      const storedExpiry = localStorage.getItem('googleOAuthTokenExpiry');
      if (storedExpiry && Date.now() > parseInt(storedExpiry)) {
        console.log('Token expired, clearing...');
        accessToken = null;
        localStorage.removeItem('googleOAuthToken');
        localStorage.removeItem('googleOAuthTokenExpiry');
        throw new Error('Your session has expired. Please sign in again.');
      }
      
      if (!accessToken) {
        throw new Error('Not signed in. Please sign in to view data.');
      }
      
      // If sheetName is provided, use it; otherwise use default range
      const rangeParam = sheetName ? `${sheetName}!${range}` : range;
      const apiUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${rangeParam}`;
      
      const response = await fetch(apiUrl, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });
      
      if (!response.ok) {
        const error = await response.json();
        // If 401, token is invalid - clear it
        if (response.status === 401) {
          accessToken = null;
          localStorage.removeItem('googleOAuthToken');
          localStorage.removeItem('googleOAuthTokenExpiry');
          throw new Error('Your session has expired. Please sign in again.');
        }
        throw new Error(error.error?.message || `API Error: ${response.status}`);
      }
      
      const data = await response.json();
      return data.values || [];
    }

    // Fetch Zone Notes sheet (Zone Notes and KML URL)
    async function fetchMetadata(sheetId) {
      if (!accessToken) {
        console.log('No access token for metadata fetch');
        return null;
      }
      
      try {
        // Try to fetch from "Zone Notes" sheet
        console.log('Attempting to fetch Zone Notes sheet...');
        const metadataValues = await fetchViaOAuth(sheetId, 'A1:B10', 'Zone Notes');
        console.log('Metadata values received:', metadataValues);
        
        if (!metadataValues || metadataValues.length === 0) {
          console.log('Zone Notes sheet is empty or not found');
          return null;
        }
        
        let notes = '';
        let kmlUrl = '';
        
        // Parse metadata - look for "Zone Notes" and "KML URL" rows
        for (let i = 0; i < metadataValues.length; i++) {
          const row = metadataValues[i];
          if (row && row.length >= 2) {
            const key = (row[0] || '').toString().trim().toLowerCase();
            const value = (row[1] || '').toString().trim();
            
            console.log(`Metadata row ${i}: key="${key}", value="${value}"`);
            
            if (key.includes('zone note') || key === 'notes') {
              notes = value;
              console.log('Found Zone Notes:', notes);
            } else if (key.includes('kml') || key.includes('boundary')) {
              // Clean the URL - remove quotes, trim whitespace
              kmlUrl = value.replace(/^["']|["']$/g, '').trim();
              console.log('Found KML URL:', kmlUrl);
            }
          }
        }
        
        return { notes, kmlUrl };
      } catch (error) {
        console.error('Error fetching Zone Notes sheet:', error);
        console.log('Zone Notes sheet not found or error reading it:', error.message);
        return null;
      }
    }

    // Parse CSV text to array of objects
    function parseCSV(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];

      // Parse header
      const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // Parse data rows
      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
        if (values.length === 0 || values.every(v => !v)) continue;
        
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        data.push(row);
      }
      
      return { headers, data };
    }

    // Convert API response (array of arrays) to object format
    function parseApiData(apiValues) {
      if (!apiValues || apiValues.length === 0) return { headers: [], data: [] };
      
      const headers = apiValues[0].map(h => h.trim());
      const data = [];
      
      for (let i = 1; i < apiValues.length; i++) {
        const row = {};
        headers.forEach((header, index) => {
          row[header] = apiValues[i][index] || '';
        });
        // Only add row if it has at least one non-empty value
        if (Object.values(row).some(v => v.trim())) {
          data.push(row);
        }
      }
      
      return { headers, data };
    }

    // Fetch and process spreadsheet data
    async function loadAddressData(sheetUrl) {
      // Save current scroll position before refreshing (if we're refreshing, not initial load)
      if (sheetData.addressMap) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      addressPanelContent.innerHTML = '<div class="loading">Loading addresses...</div>';

      // Require OAuth sign-in to read data
      if (!accessToken) {
        addressPanelContent.innerHTML = '<div class="error">Please sign in with Google to view data.</div>';
        // Show sign-in prompt
        signinPrompt.style.display = 'block';
        return;
      }

      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        addressPanelContent.innerHTML = '<div class="error">Invalid Google Sheets URL</div>';
        return;
      }
      
      try {
        let headers, data;
        
        // Use OAuth to fetch data
        console.log('Fetching data via OAuth...');
        try {
          const apiValues = await fetchViaOAuth(sheetInfo.sheetId);
          const parsed = parseApiData(apiValues);
          headers = parsed.headers;
          data = parsed.data;
          console.log('Successfully loaded via OAuth');
          
          // Also fetch Zone Notes sheet
          metadataSheetId = sheetInfo.sheetId;
          console.log('Fetching Zone Notes sheet...');
          const metadata = await fetchMetadata(sheetInfo.sheetId);
          if (metadata) {
            console.log('Metadata found:', metadata);
            zoneNotes = metadata.notes || '';
            zoneKmlUrl = metadata.kmlUrl || '';
            updateZoneNotesUI();
            // Auto-load KML if URL is provided (wait for map to initialize if needed)
            if (zoneKmlUrl) {
              console.log('Auto-loading KML from Zone Notes sheet:', zoneKmlUrl);
              if (zoneMap) {
                loadKMLBoundary(zoneKmlUrl);
              } else {
                // Wait a bit for map to initialize, then load KML
                setTimeout(() => {
                  if (zoneMap && zoneKmlUrl) {
                    console.log('Loading KML after map initialization:', zoneKmlUrl);
                    loadKMLBoundary(zoneKmlUrl);
                  }
                }, 1000);
              }
            } else {
              console.log('No KML URL found in Zone Notes sheet');
            }
          } else {
            console.log('No metadata found or Zone Notes sheet does not exist');
          }
        } catch (oauthError) {
          console.error('OAuth fetch failed:', oauthError);
          throw new Error(`Error loading data: ${oauthError.message}. Make sure you're signed in and have access to this sheet.`);
        }
        
        // No fallback - OAuth is required
        if (!headers || !data) {
          // Fall back to CSV export (requires published sheet)
          const csvUrl = getCsvUrl(sheetUrl);
          if (!csvUrl) {
            throw new Error('Could not generate CSV URL');
          }

          // Try direct fetch first, then CORS proxy if needed
          let csvText;
          try {
            const response = await fetch(csvUrl);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            csvText = await response.text();
          } catch (error) {
            // If direct fetch fails, try CORS proxy
            console.log('Direct fetch failed, trying CORS proxy...', error);
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`;
            const proxyResponse = await fetch(proxyUrl);
            if (!proxyResponse.ok) {
              throw new Error(`Proxy fetch failed: ${proxyResponse.status}. Please sign in with Google.`);
            }
            csvText = await proxyResponse.text();
          }
          
          if (!csvText || csvText.trim().length === 0) {
            throw new Error('Spreadsheet appears to be empty or could not be accessed.');
          }
          
          const parsed = parseCSV(csvText);
          headers = parsed.headers;
          data = parsed.data;
        }
        
        if (data.length === 0) {
          addressPanelContent.innerHTML = '<div class="empty">No data found in spreadsheet</div>';
          return;
        }

        // Find address columns - prefer separate House # and Street, fallback to Address
        const houseNumCol = headers.find(h => {
          const lower = h.toLowerCase();
          // Match "House #" exactly (case-insensitive) or variations
          return h === 'House #' || 
                 lower === 'house #' ||
                 lower.includes('house #') || 
                 lower.includes('house#') ||
                 lower === 'house number' ||
                 lower === 'house num' ||
                 (lower === 'house' && !lower.includes('hold')); // "house" but not "household"
        });
        const streetCol = headers.find(h => {
          const lower = h.toLowerCase();
          // Match "Street" exactly (case-insensitive) or variations
          return h === 'Street' ||
                 lower === 'street' ||
                 (lower.includes('street') && !lower.includes('address'));
        });
        const addressCol = headers.find(h => {
          const lower = h.toLowerCase();
          return (lower.includes('address') || lower.includes('location')) &&
                 !lower.includes('email') && !lower.includes('phone');
        });

        // Helper function to get address string
        const getAddressString = (row) => {
          if (houseNumCol && streetCol) {
            const houseNum = (row[houseNumCol] || '').trim();
            const street = (row[streetCol] || '').trim();
            if (houseNum && street) {
              return `${houseNum} ${street}`;
            } else if (street) {
              return street;
            } else if (houseNum) {
              return houseNum;
            }
          }
          // Fallback to Address column if it exists
          if (addressCol) {
            return (row[addressCol] || '').trim();
          }
          return null;
        };

        // Check if we have at least one way to identify addresses
        if (!houseNumCol && !streetCol && !addressCol) {
          const availableCols = headers.slice(0, 10).join(', ');
          addressPanelContent.innerHTML = `<div class="error">No address columns found. Need either "House #" and "Street" columns, or an "Address" column. Available columns: ${availableCols || 'none'}</div>`;
          return;
        }

        // Group data by address, storing original row index with each row
        const addressMap = new Map();
        data.forEach((row, rowIndex) => {
          const address = getAddressString(row);
          if (!address) return;
          
          if (!addressMap.has(address)) {
            addressMap.set(address, []);
          }
          // Store row with its original index
          addressMap.get(address).push({ ...row, __originalIndex: rowIndex });
        });

        // Store data globally
        sheetData = { headers, data, addressMap, addressCol, houseNumCol, streetCol, getAddressString };
        
        // Update header with Zone information
        const zoneCol = headers.find(h => h.toLowerCase().includes('zone'));
        let zoneValue = '';
        if (zoneCol && data.length > 0 && data[0][zoneCol]) {
          zoneValue = data[0][zoneCol].trim();
        }
        const navTitle = document.getElementById('navTitle');
        if (zoneValue) {
          navTitle.textContent = `${zoneValue} ‚Ä¢ Altagether Zone Dashboard`;
        } else {
          navTitle.textContent = 'Altagether Zone Dashboard';
        }
        
        // Store sheet ID for writing (sheetInfo already defined above)
        if (sheetInfo) {
          currentSheetId = sheetInfo.sheetId;
        }
        
        // Update sign-in UI
        updateSignInUI();
        
        // Reset filters when loading new data
        currentStreetFilter = 'all';
        currentDamageFilter = 'all';
        currentStatusFilter = 'all';
        
        // If an address was selected, restore that view; otherwise show list
        if (selectedAddress && addressMap.has(selectedAddress)) {
          displayAddressDetails(selectedAddress, true); // true = preserve scroll
        } else {
          displayAddressList(Array.from(addressMap.keys()).sort());
          // Restore scroll position for list view
          setTimeout(() => {
            addressPanelContent.scrollTop = savedScrollPosition;
          }, 0);
        }
        
        // Update zone progress charts
        updateZoneProgressCharts();
        
        // Initialize or update map with addresses
        initializeMap();
        updateMapMarkers();
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        const errorMsg = error.message || 'Unknown error';
        
        // Hide zone progress panel on error
        const panel = document.getElementById('zoneProgressPanel');
        if (panel) panel.style.display = 'none';
        
        let helpText = '';
        if (errorMsg.includes('permission') || errorMsg.includes('does not have permission') || errorMsg.includes('sign in')) {
          helpText = `<br><br><strong>Solution:</strong><br>
            1. Click "Sign in with Google" above<br>
            2. Grant permission to access Google Sheets<br>
            3. Make sure you have access to the sheet (it should be shared with you or set to "Anyone with the link can edit")<br>
            4. Refresh and try again`;
        } else {
          helpText = `<br><br>Tips:<br>‚Ä¢ Sign in with Google to view and edit data<br>‚Ä¢ Make sure the sheet is shared with you or set to "Anyone with the link can edit"<br>‚Ä¢ Make sure the sheet has an "Address" column`;
        }
        
        addressPanelContent.innerHTML = `<div class="error">Error loading spreadsheet: ${errorMsg}${helpText}</div>`;
      }
    }

    // Extract street name from full address
    function extractStreet(address) {
      // Use Street column if available (preferred method)
      if (sheetData && sheetData.streetCol && sheetData.addressMap && sheetData.addressMap.has(address)) {
        const rows = sheetData.addressMap.get(address);
        if (rows && rows.length > 0 && rows[0][sheetData.streetCol]) {
          return rows[0][sheetData.streetCol].trim();
        }
      }
      // Fallback: try to extract from address string (e.g., "2054 MADISON AVE" -> "MADISON AVE")
      // This is a simple fallback - assumes format like "NUMBER STREET"
      const parts = address.split(/\s+/);
      if (parts.length > 1) {
        return parts.slice(1).join(' '); // Everything after the first part (house number)
      }
      return address;
    }

    // Get unique streets from all addresses
    function getUniqueStreets(addresses) {
      const streets = new Set();
      addresses.forEach(addr => {
        const street = extractStreet(addr);
        if (street) streets.add(street);
      });
      return Array.from(streets).sort();
    }

    // Get unique damage values from all addresses
    function getUniqueDamage(addresses) {
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      if (!damageCol) return [];
      
      const damages = new Set();
      // Check all data, not just filtered addresses
      sheetData.data.forEach(row => {
        if (row[damageCol] !== undefined && row[damageCol] !== null) {
          const damage = String(row[damageCol]).trim();
          if (damage) damages.add(damage);
        }
      });
      
      // Always include default values (even if not in data yet)
      const defaultDamageValues = ['Total Loss', 'Partial Loss', 'Standing'];
      defaultDamageValues.forEach(val => {
        // Check if this value exists (case-insensitive)
        const existing = Array.from(damages).find(d => d.toLowerCase() === val.toLowerCase());
        if (existing && existing !== val) {
          // Replace with exact case from defaults
          damages.delete(existing);
        }
        damages.add(val);
      });
      
      return Array.from(damages).sort();
    }

    // Get unique household status values from all addresses
    function getUniqueStatus(addresses) {
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (!statusCol) return [];
      
      const statuses = new Set();
      // Check all data, not just filtered addresses
      sheetData.data.forEach(row => {
        if (row[statusCol] !== undefined && row[statusCol] !== null) {
          const status = String(row[statusCol]).trim();
          if (status) statuses.add(status);
        }
      });
      
      // Always include default values (even if not in data yet)
      const defaultStatusValues = ['Planning to Rebuild', 'Selling', 'Renter/Moved', 'Staying'];
      defaultStatusValues.forEach(val => {
        // Check if this value exists (case-insensitive)
        const existing = Array.from(statuses).find(s => s.toLowerCase() === val.toLowerCase());
        if (existing && existing !== val) {
          // Replace with exact case from defaults
          statuses.delete(existing);
        }
        statuses.add(val);
      });
      
      return Array.from(statuses).sort();
    }

    // Get damage value for an address
    function getAddressDamage(address) {
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      if (!damageCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][damageCol]?.trim() || null;
      }
      return null;
    }

    // Get household status value for an address
    function getAddressStatus(address) {
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (!statusCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][statusCol]?.trim() || null;
      }
      return null;
    }

    // Display list of addresses
    function displayAddressList(addresses) {
      // Clear selected address when showing list
      selectedAddress = null;
      
      if (addresses.length === 0) {
        addressPanelContent.innerHTML = '<div class="empty">No addresses found</div>';
        return;
      }

      // Get unique values for all filters
      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      const statuses = getUniqueStatus(addresses);
      
      // Filter addresses by all selected filters
      const filteredAddresses = addresses.filter(addr => {
        // Street filter
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) {
          return false;
        }
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const addrDamage = getAddressDamage(addr);
          if (addrDamage !== currentDamageFilter) {
            return false;
          }
        }
        // Status filter
        if (currentStatusFilter !== 'all') {
          const addrStatus = getAddressStatus(addr);
          if (addrStatus !== currentStatusFilter) {
            return false;
          }
        }
        return true;
      });

      const html = `
        <div class="address-filters">
          <select id="streetFilter">
            <option value="all" ${currentStreetFilter === 'all' ? 'selected' : ''}>All Streets</option>
            ${streets.map(street => `
              <option value="${street.replace(/"/g, '&quot;')}" ${currentStreetFilter === street ? 'selected' : ''}>${street}</option>
            `).join('')}
          </select>
          <select id="damageFilter">
            <option value="all" ${currentDamageFilter === 'all' ? 'selected' : ''}>All Damage Status</option>
            ${damages.map(damage => `
              <option value="${damage.replace(/"/g, '&quot;')}" ${currentDamageFilter === damage ? 'selected' : ''}>${damage}</option>
            `).join('')}
          </select>
          <select id="statusFilter">
            <option value="all" ${currentStatusFilter === 'all' ? 'selected' : ''}>All Household Status</option>
            ${statuses.map(status => `
              <option value="${status.replace(/"/g, '&quot;')}" ${currentStatusFilter === status ? 'selected' : ''}>${status}</option>
            `).join('')}
          </select>
        </div>
        <ul class="address-list">
          ${filteredAddresses.map(addr => `
            <li class="address-item" data-address="${addr.replace(/"/g, '&quot;')}">
              ${addr}
            </li>
          `).join('')}
        </ul>
      `;
      
      addressPanelContent.innerHTML = html;
      
      // Add filter change handlers
      const streetFilter = document.getElementById('streetFilter');
      if (streetFilter) {
        streetFilter.addEventListener('change', (e) => {
          currentStreetFilter = e.target.value;
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
        });
      }
      
      const damageFilter = document.getElementById('damageFilter');
      if (damageFilter) {
        damageFilter.addEventListener('change', (e) => {
          currentDamageFilter = e.target.value;
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
        });
      }
      
      const statusFilter = document.getElementById('statusFilter');
      if (statusFilter) {
        statusFilter.addEventListener('change', (e) => {
          currentStatusFilter = e.target.value;
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers(); // Update map when filter changes
        });
      }
      
      // Update map markers when filters change
      updateMapMarkers();

      // Add click handlers
      document.querySelectorAll('.address-item').forEach(item => {
        item.addEventListener('click', () => {
          const address = item.getAttribute('data-address');
          displayAddressDetails(address);
          
          // Update active state
          document.querySelectorAll('.address-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
        });
      });
    }

    // Display details for a specific address
    function displayAddressDetails(address, preserveScroll = false) {
      if (!sheetData.addressMap || !sheetData.addressMap.has(address)) {
        return;
      }

      // Track selected address
      selectedAddress = address;
      
      // Save scroll position if we're refreshing
      if (preserveScroll) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      const rows = sheetData.addressMap.get(address);
      const { headers, addressCol } = sheetData;

      // Find relevant columns (exclude address column itself)
      const detailCols = headers.filter(h => 
        h !== addressCol && 
        h.toLowerCase() !== 'address' &&
        rows.some(row => row[h] && row[h].trim())
      );
      
      // Define which address-level fields to DISPLAY (others are hidden)
      // Note: "address" is excluded since it's shown as the heading
      const addressLevelDisplayFields = [
        'household size',
        'damage',
        'household status',
        'address notes'
      ];
      
      // Separate address-level and person-level columns
      const addressLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Explicitly exclude person-level notes and email address
        if (lower.includes('person note')) return false;
        if (lower.includes('email address')) return false;
        // Address-level: fields that are the same for all people at this address
        // But only include if they're in the display list
        const isSameForAll = rows.length > 0 && rows.every(r => (r[h] || '').trim() === (rows[0][h] || '').trim());
        const shouldDisplay = addressLevelDisplayFields.some(field => lower.includes(field));
        return isSameForAll && shouldDisplay;
      });
      
      // Fields to hide from person view
      const hiddenFromPersonView = [
        'house #',
        'street',
        'city',
        'state',
        'zip_code',
        'resident name',
        'zone',
        'nc name',
        'nc email',
        'damage',
        'household status',
        'household size',
        'latitude',
        'longitude',
        'nc phone',
        'first name',
        'middle name',
        'last name'
      ];
      
      const personLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Skip hidden fields
        if (hiddenFromPersonView.some(field => lower.includes(field))) return false;
        // Skip Contact Notes - it's shown separately in contact mode
        if (lower.includes('contact') && lower.includes('note')) return false;
        // Person-level: Person Notes, Person Notes 2, Person Notes 3, or person-specific fields
        return lower.includes('person note') ||
               lower.includes('home phone') ||
               lower.includes('cell') ||
               lower.includes('email address') ||
               lower.includes('gender') ||
               lower.includes('age') ||
               (!addressLevelCols.includes(h) && detailCols.includes(h));
      });
      
      // Find Notes columns separately - always show them if signed in, even if empty
      // Exclude Contact Notes - it's shown separately in contact mode
      const allNotesCols = headers.filter(h => 
        h !== addressCol &&
        h.toLowerCase().includes('note') &&
        !(h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')) &&
        accessToken // Only if signed in
      );
      
      // Add Notes columns to detailCols if not already there
      allNotesCols.forEach(col => {
        if (!detailCols.includes(col)) {
          detailCols.push(col);
        }
      });

      let html = `
        <button class="btn-back" onclick="displayAddressList(Array.from(sheetData.addressMap.keys()).sort())">‚Üê Back to List</button>
        <div class="address-details active">
          <h3>${address}</h3>
      `;

      // Collect unique values for dropdown fields from ALL data
      const damageValues = new Set();
      const statusValues = new Set();
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      
      // Default status values (in case not all are found in data)
      const defaultDamageValues = ['Total Loss', 'Partial Loss', 'Standing'];
      const defaultStatusValues = ['Planning to Rebuild', 'Selling', 'Renter/Moved', 'Staying'];
      
      sheetData.data.forEach(row => {
        if (damageCol && row[damageCol] !== undefined && row[damageCol] !== null) {
          const value = String(row[damageCol]).trim();
          if (value) damageValues.add(value);
        }
        if (statusCol && row[statusCol] !== undefined && row[statusCol] !== null) {
          const value = String(row[statusCol]).trim();
          if (value) statusValues.add(value);
        }
      });
      
      // Add default values if they weren't found (ensures all options are available)
      if (damageCol) {
        defaultDamageValues.forEach(val => damageValues.add(val));
      }
      if (statusCol) {
        defaultStatusValues.forEach(val => statusValues.add(val));
      }
      
      console.log('Damage values found:', Array.from(damageValues));
      console.log('Status values found:', Array.from(statusValues));

      // Show address-level fields once at the top (always show, not just when signed in)
      if (addressLevelCols.length > 0) {
        html += '<div class="address-level-section" style="background: rgba(255,255,255,0.7); padding: 12px; border-radius: 6px; margin-bottom: 16px; border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 1px 3px rgba(0,0,0,0.04);">';
        
        addressLevelCols.forEach(col => {
          const firstRowValue = rows[0] ? (rows[0][col] || '') : '';
          const lower = col.toLowerCase();
          const isNotes = lower.includes('note');
          const isDamage = lower.includes('damage');
          const isStatus = lower.includes('household status');
          const isEditable = accessToken; // All fields editable when signed in
          
          if (isEditable) {
            if (isNotes) {
              // Notes: expandable textarea
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-address-level="true"
                     data-column="${col}"
                     data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue}</textarea>
              </div>`;
            } else if (isDamage || isStatus) {
              // Damage/Status: dropdown
              const options = isDamage ? Array.from(damageValues).sort() : Array.from(statusValues).sort();
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <select class="editable-dropdown" 
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">
                  <option value="">(not set)</option>
                  ${options.map(opt => `<option value="${opt.replace(/"/g, '&quot;')}" ${opt === firstRowValue ? 'selected' : ''}>${opt}</option>`).join('')}
                </select>
              </div>`;
            } else {
              // Other fields: subtle editable
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-address-level="true"
                      data-column="${col}"
                      data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue || ''}</span>
              </div>`;
            }
          } else {
            // Not signed in: display only
            html += `<div class="person-info"><strong>${col}:</strong> ${firstRowValue || '(not set)'}</div>`;
          }
        });
        
        html += '</div>';
      }

      // Check if contact mode is active
      const isContactMode = window.contactModeActive || false;
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );

      // Show person-level fields for each person
      rows.forEach((row, index) => {
        // Get the original row index that was stored when grouping
        const originalRowIndex = row.__originalIndex !== undefined ? row.__originalIndex : -1;
        
        // Check contact status
        const lastContact = lastContactCol ? (row[lastContactCol] || '').trim() : '';
        const isContacted = lastContact && lastContact.length > 0;
        const contactClass = isContacted ? 'recent-contact' : (isContactMode ? 'no-contact' : '');
        
        html += `<div class="person-entry ${contactClass}">`;
        
        // Try to find name column - show Resident Name as the person's name
        const nameCol = headers.find(h => 
          h.toLowerCase().includes('resident name') || 
          (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name'))
        );
        
        if (nameCol && row[nameCol]) {
          html += `<div class="person-name">${row[nameCol]}</div>`;
        } else if (rows.length > 1) {
          html += `<div class="person-name">Person ${index + 1}</div>`;
        }

        // Contact mode: show contact button and quick notes
        if (isContactMode && accessToken) {
          html += `
            <div style="margin-top: 8px; margin-bottom: 8px;">
              <button class="contact-button ${isContacted ? 'contacted' : ''}" 
                      data-address="${address.replace(/"/g, '&quot;')}"
                      data-original-row-index="${originalRowIndex}"
                      data-column="${lastContactCol || 'Last Contact Date'}"
                      onclick="markContact(this, '${address.replace(/"/g, '&quot;')}', ${originalRowIndex}, '${lastContactCol || 'Last Contact Date'}')">
                ${isContacted ? '‚úì Contacted' : 'Mark as Contacted'}
              </button>
              ${isContacted ? `<div class="contact-date">Last contact: ${lastContact}</div>` : ''}
              <textarea class="contact-notes-quick" 
                        placeholder="Quick contact notes..."
                        data-address="${address.replace(/"/g, '&quot;')}"
                        data-original-row-index="${originalRowIndex}"
                        data-column="Contact Notes"
                        data-original-value="${(row['Contact Notes'] || '').replace(/"/g, '&quot;')}">${row['Contact Notes'] || ''}</textarea>
            </div>
          `;
        } else if (isContactMode && !accessToken) {
          // Contact mode but not signed in - show status only
          html += `
            <div style="margin-top: 8px; margin-bottom: 8px;">
              <div style="font-size: 0.85rem; color: ${isContacted ? '#4caf50' : '#ff9800'};">
                ${isContacted ? `‚úì Contacted (${lastContact})` : '‚ö† Not contacted'}
              </div>
            </div>
          `;
        }

        // Display person-level fields (show even if empty, like Notes)
        personLevelCols.forEach(col => {
          const isNotes = col.toLowerCase().includes('note');
          const isEditable = accessToken; // All fields editable when signed in
          
          // Skip Resident Name since we already show it as the person's name
          if (col.toLowerCase().includes('resident name')) return;
          
          // Skip Contact Notes if we're in contact mode (already shown as Quick Contact Notes)
          if (isContactMode && (col.toLowerCase().includes('contact') && col.toLowerCase().includes('note'))) return;
          
          if (isEditable) {
            if (isNotes) {
              // Notes: expandable textarea
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-original-row-index="${originalRowIndex}" 
                     data-column="${col}"
                     data-address-level="false"
                     data-original-value="${(row[col] || '').replace(/"/g, '&quot;')}">${row[col] || ''}</textarea>
              </div>`;
            } else {
              // Other fields: subtle editable
              const value = row[col] || '';
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-original-row-index="${originalRowIndex}" 
                      data-column="${col}"
                      data-address-level="false"
                      data-original-value="${value.replace(/"/g, '&quot;')}">${value || ''}</span>
              </div>`;
            }
          } else {
            // Show all person-level fields, even if empty
            const value = row[col] || '';
            html += `<div class="person-info"><strong>${col}:</strong> ${value || '(not set)'}</div>`;
          }
        });
        
        // Display other non-notes fields that aren't address-level (but exclude hidden fields)
        detailCols.forEach(col => {
          const lower = col.toLowerCase();
          const isHidden = hiddenFromPersonView.some(field => lower.includes(field));
          if (!addressLevelCols.includes(col) && !personLevelCols.includes(col) && 
              !col.toLowerCase().includes('note') && !isHidden) {
            if (row[col] && row[col].trim()) {
              html += `<div class="person-info"><strong>${col}:</strong> ${row[col]}</div>`;
            }
          }
        });

        html += '</div>';
      });

      // Add save button if signed in and there are editable fields
      if (accessToken) {
        html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 2px solid var(--river);">
            <button class="btn-save" id="saveChangesBtn">Save Changes</button>
            <span class="save-status" id="saveStatus"></span>
          </div>
        `;
      }

      html += '</div>';
      addressPanelContent.innerHTML = html;
      
      // Add save button handler
      const saveBtn = document.getElementById('saveChangesBtn');
      if (saveBtn) {
        saveBtn.addEventListener('click', saveChanges);
      }
      
      // Add change handlers for dropdowns
      document.querySelectorAll('.editable-dropdown').forEach(dropdown => {
        dropdown.addEventListener('change', () => {
          // Mark as changed for save
          dropdown.setAttribute('data-changed', 'true');
        });
      });
      
      // Restore scroll position if refreshing, otherwise scroll to top
      setTimeout(() => {
        if (preserveScroll) {
          addressPanelContent.scrollTop = savedScrollPosition;
        } else {
          addressPanelContent.scrollTop = 0; // Start at top for new address
        }
      }, 0);
    }

    // Load sheet button handler
    btn.addEventListener("click", () => {
      let url = input.value.trim();
      if (!url) return;

      if (url.includes("/view")) {
        url = url.replace("/view", "/edit");
      }

      currentSheetUrl = url;
      // Save to localStorage
      localStorage.setItem('savedSheetUrl', url);
      frame.src = url;
      
      // Also load the address data
      loadAddressData(url);
    });

    // Refresh button handler
    refreshBtn.addEventListener("click", () => {
      if (currentSheetUrl) {
        loadAddressData(currentSheetUrl);
      }
    });

    // Convert column index to letter (A, B, C, etc.) - global helper function
    function indexToColumnLetter(index) {
      let result = '';
      while (index >= 0) {
        result = String.fromCharCode(65 + (index % 26)) + result;
        index = Math.floor(index / 26) - 1;
      }
      return result;
    }

    // Save changes to spreadsheet
    async function saveChanges() {
      if (!accessToken || !currentSheetId) {
        alert('Please sign in to save changes.');
        return;
      }

      const saveBtn = document.getElementById('saveChangesBtn');
      const saveStatus = document.getElementById('saveStatus');
      // Get all editable elements: Notes fields (textareas), inline fields, dropdowns, and Quick Contact Notes
      const editableFields = document.querySelectorAll('.editable-field[contenteditable="true"], .editable-inline[contenteditable="true"], .editable-notes, .contact-notes-quick');
      const editableDropdowns = document.querySelectorAll('.editable-dropdown');
      
      if (editableFields.length === 0 && editableDropdowns.length === 0) {
        return;
      }

      saveBtn.disabled = true;
      saveStatus.textContent = 'Saving...';
      saveStatus.className = 'save-status saving';

      try {
        // Collect all changes
        const updates = [];
        editableFields.forEach(field => {
          // Handle textareas differently from contenteditable divs
          const newValue = field.tagName === 'TEXTAREA' ? field.value.trim() : field.textContent.trim();
          const originalValue = field.getAttribute('data-original-value') || '';
          const column = field.getAttribute('data-column');
          const isAddressLevel = field.getAttribute('data-address-level') === 'true';
          const address = field.getAttribute('data-address');
          const originalRowIndex = parseInt(field.getAttribute('data-original-row-index'));

          if (newValue !== originalValue) {
            // Find the column index - handle Contact Notes with flexible matching
            let colIndex = -1;
            if (column === 'Contact Notes' || field.classList.contains('contact-notes-quick')) {
              // For Contact Notes, use flexible search like markContact does
              colIndex = sheetData.headers.findIndex(h => 
                h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')
              );
            } else {
              colIndex = sheetData.headers.indexOf(column);
            }
            if (colIndex === -1) {
              console.warn(`Column not found: ${column}`);
              return;
            }

            // Convert column index to letter (A, B, C, etc.)
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            } else {
              // Person-level: update only this specific row
              if (originalRowIndex !== -1) {
                const rowNumber = originalRowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                const range = `${colLetter}${rowNumber}`;
                updates.push({
                  range: `Sheet1!${range}`,
                  values: [[newValue]]
                });
              }
            }
          }
        });
        
        // Handle dropdown fields
        editableDropdowns.forEach(dropdown => {
          const newValue = dropdown.value.trim();
          const originalValue = dropdown.getAttribute('data-original-value');
          const column = dropdown.getAttribute('data-column');
          const isAddressLevel = dropdown.getAttribute('data-address-level') === 'true';
          const address = dropdown.getAttribute('data-address');

          if (newValue !== originalValue) {
            // Find the column index
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex === -1) return;

            // Convert column index to letter
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2;
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            }
          }
        });

        if (updates.length === 0) {
          saveStatus.textContent = 'No changes to save';
          saveStatus.className = 'save-status';
          saveBtn.disabled = false;
          return;
        }

        // Use Google Sheets API to update
        const response = await fetch(
          `https://sheets.googleapis.com/v4/spreadsheets/${currentSheetId}/values:batchUpdate`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              valueInputOption: 'USER_ENTERED',
              data: updates
            })
          }
        );

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'Failed to save');
        }

        // Update original values
        editableFields.forEach(field => {
          const value = field.tagName === 'TEXTAREA' ? field.value.trim() : field.textContent.trim();
          // Escape HTML entities for data attribute
          const escapedValue = value.replace(/"/g, '&quot;').replace(/\n/g, '&#10;');
          field.setAttribute('data-original-value', escapedValue);
        });
        editableDropdowns.forEach(dropdown => {
          dropdown.setAttribute('data-original-value', dropdown.value.trim());
        });

        saveStatus.textContent = 'Saved!';
        saveStatus.className = 'save-status saved';
        
        // Refresh data after a short delay
        setTimeout(() => {
          if (currentSheetUrl) {
            loadAddressData(currentSheetUrl);
          }
        }, 1000);

      } catch (error) {
        console.error('Save error:', error);
        saveStatus.textContent = `Error: ${error.message}`;
        saveStatus.className = 'save-status error';
      } finally {
        saveBtn.disabled = false;
      }
    }

    // Initialize Leaflet map
    function initializeMap() {
      const mapDiv = document.getElementById('zoneMap');
      if (!mapDiv) {
        console.error('Map div not found');
        return;
      }
      
      if (!zoneMap) {
        try {
          // Default center (Altadena, CA - adjust as needed)
          zoneMap = L.map('zoneMap').setView([34.19, -118.15], 13);
          
          // Add OpenStreetMap tiles (default)
          currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(zoneMap);
          
          console.log('Map initialized');
        } catch (error) {
          console.error('Error initializing map:', error);
        }
      }
      
      // Load KML if URL is provided (commented out for now)
      // const kmlUrlInput = document.getElementById("kmlUrlInput");
      // const kmlUrl = kmlUrlInput && kmlUrlInput.value ? kmlUrlInput.value.trim() : '';
      // if (kmlUrl) {
      //   loadKMLBoundary(kmlUrl);
      // }
    }

    // Convert Google Drive sharing URL to direct download URL
    function convertGoogleDriveUrl(url) {
      // Extract file ID from Google Drive sharing URL
      // Format: https://drive.google.com/file/d/FILE_ID/view?usp=sharing
      // Or: https://drive.google.com/open?id=FILE_ID
      let fileId = null;
      
      // Try pattern 1: /file/d/FILE_ID/
      const match1 = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
      if (match1 && match1[1]) {
        fileId = match1[1];
      } else {
        // Try pattern 2: ?id=FILE_ID
        const match2 = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
        if (match2 && match2[1]) {
          fileId = match2[1];
        }
      }
      
      if (fileId) {
        // Try alternative Google Drive export URL format
        // The confirm=t parameter sometimes helps bypass virus scan
        return `https://drive.google.com/uc?export=download&id=${fileId}&confirm=t`;
      }
      
      // If it's already a direct download URL or other format, return as-is
      return url;
    }

    // Load KML boundary
    async function loadKMLBoundary(kmlUrl) {
      if (!kmlUrl || !kmlUrl.trim()) {
        console.log('No KML URL provided');
        return;
      }
      
      try {
        // Remove existing KML layer
        if (kmlLayer) {
          zoneMap.removeLayer(kmlLayer);
        }
        
        // Clean the URL - remove any quotes or extra whitespace
        const cleanUrl = kmlUrl.replace(/^["']|["']$/g, '').trim();
        console.log('Cleaned KML URL:', cleanUrl);
        
        // Convert Google Drive URL if needed
        const directUrl = convertGoogleDriveUrl(cleanUrl);
        console.log('Loading KML from:', directUrl);
        
        // Fetch KML file with CORS proxy fallback and timeout handling
        let kmlText;
        try {
          // Try direct fetch first with timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          try {
            const response = await fetch(directUrl, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              throw new Error(`Direct fetch failed: ${response.status}`);
            }
            kmlText = await response.text();
          } catch (fetchError) {
            clearTimeout(timeoutId);
            throw fetchError; // Re-throw to be caught by outer catch
          }
        } catch (error) {
          // If direct fetch fails (CORS issue or timeout), try multiple proxy services
          if (error.name === 'AbortError') {
            console.log('Direct fetch timed out, trying CORS proxy...');
          } else {
            console.log('Direct fetch failed, trying CORS proxy...', error);
          }
          
          // Try multiple proxy services with fallback
          const proxyServices = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(directUrl)}`,
            `https://corsproxy.io/?${encodeURIComponent(directUrl)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(directUrl)}`
          ];
          
          let lastError = null;
          let success = false;
          
          for (const proxyUrl of proxyServices) {
            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout for proxy
              
              const response = await fetch(proxyUrl, { signal: controller.signal });
              clearTimeout(timeoutId);
              
              if (response.ok) {
                kmlText = await response.text();
                success = true;
                console.log('Successfully loaded KML via proxy:', proxyUrl);
                break; // Success, exit loop
              } else {
                lastError = new Error(`Proxy returned ${response.status}: ${response.statusText}`);
                console.log(`Proxy ${proxyUrl} returned ${response.status}`);
              }
            } catch (proxyError) {
              if (proxyError.name === 'AbortError') {
                lastError = new Error('Proxy request timed out');
              } else {
                lastError = proxyError;
              }
              console.log(`Proxy ${proxyUrl} failed:`, lastError.message);
              continue; // Try next proxy
            }
          }
          
          if (!success) {
            throw new Error(`Failed to fetch KML: ${lastError ? lastError.message : 'All proxy services failed'}. The KML file may be too large, the URL may be invalid, or the file may not be publicly accessible. Try using a direct download link or a smaller KML file.`);
          }
        }
        
        // Parse KML to GeoJSON
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlText, 'text/xml');
        
        // Check for parsing errors
        const parseError = kml.querySelector('parsererror');
        if (parseError) {
          throw new Error('KML parsing error: ' + parseError.textContent);
        }
        
        // Convert KML to GeoJSON (toGeoJSON is from @mapbox/togeojson)
        let geojson;
        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
          geojson = toGeoJSON.kml(kml);
        } else {
          throw new Error('toGeoJSON library not loaded');
        }
        
        // Add to map
        kmlLayer = L.geoJSON(geojson, {
          style: {
            color: '#214025',
            weight: 3,
            opacity: 0.8,
            fillColor: '#214025',
            fillOpacity: 0.1
          }
        }).addTo(zoneMap);
        
        // Fit map to boundary
        if (kmlLayer.getBounds && kmlLayer.getBounds().isValid()) {
          zoneMap.fitBounds(kmlLayer.getBounds(), { padding: [20, 20] });
        }
      } catch (error) {
        console.error('Error loading KML:', error);
        alert('Error loading KML file: ' + error.message);
      }
    }

    // Update map markers based on filtered addresses
    function updateMapMarkers() {
      if (!sheetData || !sheetData.addressMap) {
        console.log('No sheet data available for map');
        return;
      }
      
      // Make sure map is initialized
      if (!zoneMap) {
        console.log('Map not initialized, initializing now...');
        initializeMap();
        if (!zoneMap) {
          console.error('Failed to initialize map');
          return;
        }
      }
      
      // Clear existing markers
      addressMarkers.forEach(marker => zoneMap.removeLayer(marker));
      addressMarkers = [];
      
      // Get filtered addresses (same logic as displayAddressList)
      const addresses = Array.from(sheetData.addressMap.keys());
      const filteredAddresses = addresses.filter(address => {
        // Street filter
        if (currentStreetFilter !== 'all') {
          const street = extractStreet(address);
          if (street !== currentStreetFilter) return false;
        }
        
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const damage = getAddressDamage(address);
          if (damage !== currentDamageFilter) return false;
        }
        
        // Status filter
        if (currentStatusFilter !== 'all') {
          const status = getAddressStatus(address);
          if (status !== currentStatusFilter) return false;
        }
        
        return true;
      });
      
      // Check for lat/lon columns
      const latCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lat') || lower === 'latitude';
      });
      const lonCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lon') || lower.includes('lng') || lower === 'longitude';
      });
      
      console.log('Looking for coordinates - Lat column:', latCol, 'Lon column:', lonCol);
      console.log('Available headers:', sheetData.headers);
      
      if (!latCol || !lonCol) {
        console.log('Lat/Lon columns not found. Available columns:', sheetData.headers);
        return;
      }
      
      // Add markers for filtered addresses
      const bounds = [];
      let markerCount = 0;
      filteredAddresses.forEach(address => {
        const rows = sheetData.addressMap.get(address);
        if (!rows || rows.length === 0) return;
        
        const firstRow = rows[0];
        let lat, lon;
        
        // Try to get coordinates from lat/lon columns
        const latVal = firstRow[latCol];
        const lonVal = firstRow[lonCol];
        
        if (latVal !== undefined && latVal !== null && latVal !== '' && 
            lonVal !== undefined && lonVal !== null && lonVal !== '') {
          lat = parseFloat(String(latVal).trim());
          lon = parseFloat(String(lonVal).trim());
          if (isNaN(lat) || isNaN(lon)) {
            console.log(`Invalid coordinates for ${address}: lat=${latVal}, lon=${lonVal}`);
            return;
          }
        } else {
          return; // Skip if no coordinates
        }
        
        // Create marker
        try {
          const marker = L.marker([lat, lon]).addTo(zoneMap);
          
          // Build popup content
          let popupContent = `<strong>${address}</strong>`;
          
          // Get resident names and ages
          const nameCol = sheetData.headers.find(h => h.toLowerCase().includes('resident name') || h.toLowerCase().includes('name'));
          const ageCol = sheetData.headers.find(h => h.toLowerCase() === 'age');
          const residents = [];
          rows.forEach(row => {
            if (nameCol && row[nameCol] && row[nameCol].trim()) {
              let residentLine = row[nameCol].trim();
              // Add age if available
              if (ageCol && row[ageCol] && row[ageCol].toString().trim()) {
                residentLine += ', ' + row[ageCol].toString().trim();
              }
              residents.push(residentLine);
            }
          });
          if (residents.length > 0) {
            popupContent += '<br>' + residents.join('<br>');
          }
          
          // Get damage and household status
          const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
          const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
          const info = [];
          if (damageCol && firstRow[damageCol] && firstRow[damageCol].trim()) {
            info.push(firstRow[damageCol].trim());
          }
          if (statusCol && firstRow[statusCol] && firstRow[statusCol].trim()) {
            info.push(firstRow[statusCol].trim());
          }
          if (info.length > 0) {
            popupContent += '<br><small>' + info.join(' ‚Ä¢ ') + '</small>';
          }
          
          // Add popup with address, residents, and info
          marker.bindPopup(popupContent);
          
          // Click handler to show address details
          marker.on('click', () => {
            displayAddressDetails(address);
          });
          
          addressMarkers.push(marker);
          bounds.push([lat, lon]);
          markerCount++;
        } catch (error) {
          console.error(`Error creating marker for ${address}:`, error);
        }
      });
      
      console.log(`Added ${markerCount} markers to map`);
      
      if (markerCount === 0) {
        console.log('No markers created - check that Latitude and Longitude columns have data');
        return;
      }
      
      // Fit map to show all markers (if we have markers and no KML boundary)
      if (bounds.length > 0 && !kmlLayer) {
        zoneMap.fitBounds(bounds, { padding: [20, 20] });
      }
    }

    // Map toggle button handler
    const mapToggleBtn = document.getElementById('mapToggleBtn');
    if (mapToggleBtn) {
      mapToggleBtn.addEventListener('click', () => {
        if (!zoneMap) return;
        
        // Remove current tile layer
        if (currentTileLayer) {
          zoneMap.removeLayer(currentTileLayer);
        }
        
        // Toggle between street and satellite
        if (isSatelliteMode) {
          // Switch to street map
          currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(zoneMap);
          mapToggleBtn.textContent = 'üõ∞Ô∏è';
          isSatelliteMode = false;
        } else {
          // Switch to satellite - using Google Satellite for more recent imagery
          currentTileLayer = L.tileLayer('https://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            subdomains: ['0', '1', '2', '3'],
            attribution: '¬© Google',
            maxZoom: 20
          }).addTo(zoneMap);
          mapToggleBtn.textContent = 'üó∫Ô∏è';
          isSatelliteMode = true;
        }
      });
    }

    // KML URL input handler (commented out for now)
    // if (kmlUrlInput) {
    //   kmlUrlInput.addEventListener('keypress', (e) => {
    //     if (e.key === 'Enter') {
    //       if (zoneMap) {
    //         loadKMLBoundary(kmlUrlInput.value.trim());
    //       }
    //     }
    //   });
    // }

    // Update Zone Notes UI
    function updateZoneNotesUI() {
      const zoneNotesText = document.getElementById('zoneNotesText');
      
      console.log('Updating Zone Notes UI, zoneNotes:', zoneNotes);
      
      if (zoneNotesText) {
        zoneNotesText.value = zoneNotes || '';
      } else {
        console.error('Zone Notes UI elements not found');
      }
    }

    // Tab switching functionality
    const addressesTab = document.getElementById('addressesTab');
    const zoneNotesTab = document.getElementById('zoneNotesTab');
    const zoneNotesContent = document.getElementById('zoneNotesContent');

    if (addressesTab && zoneNotesTab) {
      addressesTab.addEventListener('click', () => {
        addressesTab.classList.add('active');
        zoneNotesTab.classList.remove('active');
        if (addressPanelContent) addressPanelContent.style.display = 'block';
        if (zoneNotesContent) zoneNotesContent.style.display = 'none';
      });

      zoneNotesTab.addEventListener('click', () => {
        zoneNotesTab.classList.add('active');
        addressesTab.classList.remove('active');
        if (addressPanelContent) addressPanelContent.style.display = 'none';
        if (zoneNotesContent) zoneNotesContent.style.display = 'flex';
      });
    }

    // Save Zone Notes to Metadata sheet
    async function saveZoneNotes() {
      if (!metadataSheetId || !accessToken) {
        alert('Please sign in to save notes.');
        return;
      }

      const zoneNotesText = document.getElementById('zoneNotesText');
      const saveStatus = document.getElementById('zoneNotesStatus');
      const saveBtn = document.getElementById('saveZoneNotesBtn');
      
      if (!zoneNotesText) return;
      
      const newNotes = zoneNotesText.value.trim();
      saveBtn.disabled = true;
      saveStatus.textContent = 'Saving...';
      saveStatus.className = 'save-status-small';

      try {
        // First, try to read existing metadata to preserve KML URL
        let kmlUrlValue = zoneKmlUrl;
        try {
          const existingMetadata = await fetchMetadata(metadataSheetId);
          if (existingMetadata && existingMetadata.kmlUrl) {
            kmlUrlValue = existingMetadata.kmlUrl;
          }
        } catch (e) {
          // If Zone Notes sheet doesn't exist, we'll create it
        }

        // Prepare the metadata rows
        const values = [
          ['Zone Notes', newNotes],
          ['KML URL', kmlUrlValue || '']
        ];

        // Use batchUpdate to write to Zone Notes sheet
        const response = await fetch(
          `https://sheets.googleapis.com/v4/spreadsheets/${metadataSheetId}/values/Zone Notes!A1:B2?valueInputOption=USER_ENTERED`,
          {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              values: values
            })
          }
        );

        if (!response.ok) {
          // If Zone Notes sheet doesn't exist, try to create it first
          // For now, just show error - user can create the sheet manually
          throw new Error('Zone Notes sheet not found. Please create a sheet named "Zone Notes" with columns A (key) and B (value).');
        }

        zoneNotes = newNotes;
        saveStatus.textContent = 'Saved!';
        saveStatus.className = 'save-status-small saved';
        
        setTimeout(() => {
          saveStatus.textContent = '';
        }, 2000);

      } catch (error) {
        console.error('Save error:', error);
        saveStatus.textContent = `Error: ${error.message}`;
        saveStatus.className = 'save-status-small error';
      } finally {
        saveBtn.disabled = false;
      }
    }

    // Zone Notes save button handler
    const saveZoneNotesBtn = document.getElementById('saveZoneNotesBtn');
    if (saveZoneNotesBtn) {
      saveZoneNotesBtn.addEventListener('click', saveZoneNotes);
    }

    // Contact Mode toggle
    let contactModeActive = false;
    window.contactModeActive = false;
    const contactModeBtn = document.getElementById('contactModeBtn');
    if (contactModeBtn) {
      contactModeBtn.addEventListener('click', () => {
        contactModeActive = !contactModeActive;
        window.contactModeActive = contactModeActive;
        contactModeBtn.classList.toggle('active', contactModeActive);
        
        // If we're viewing an address detail, refresh it to show/hide contact mode UI
        const addressDetails = document.querySelector('.address-details.active');
        if (addressDetails) {
          const addressHeading = addressDetails.querySelector('h3');
          if (addressHeading) {
            const address = addressHeading.textContent.trim();
            displayAddressDetails(address);
          }
        }
      });
    }

    // Mark contact function
    window.markContact = async function(button, address, originalRowIndex, contactColumn) {
      if (!accessToken) {
        alert('Please sign in to mark contacts.');
        return;
      }

      // Get the current sheet URL - try multiple sources
      let sheetUrl = currentSheetUrl;
      if (!sheetUrl) {
        sheetUrl = localStorage.getItem('savedSheetUrl') || '';
      }
      if (!sheetUrl) {
        alert('No sheet loaded. Please load a spreadsheet first.');
        return;
      }

      const today = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      });

      try {
        const sheetInfo = extractSheetId(sheetUrl);
        if (!sheetInfo || !sheetInfo.sheetId) {
          console.error('Sheet URL:', sheetUrl);
          console.error('Sheet Info:', sheetInfo);
          throw new Error('Invalid sheet URL. Make sure a spreadsheet is loaded.');
        }

        // Find the row to update (using originalRowIndex + 2 because row 1 is header, row 2 is first data)
        const rowNumber = originalRowIndex + 2;

        // Get column letters for contact date and contact notes
        const headers = sheetData.headers;
        const contactColIndex = headers.findIndex(h => 
          h.toLowerCase() === 'last contact date' ||
          h.toLowerCase().includes('last contact') || 
          h.toLowerCase().includes('contact date') ||
          h.toLowerCase().includes('contacted')
        );
        
        const contactNotesColIndex = headers.findIndex(h => 
          h.toLowerCase() === 'contact notes' ||
          h.toLowerCase().includes('contact notes')
        );

        console.log('Contact Notes column search:', {
          headers: headers,
          contactNotesColIndex: contactNotesColIndex,
          foundColumn: contactNotesColIndex >= 0 ? headers[contactNotesColIndex] : 'NOT FOUND'
        });

        // Get contact notes from the textarea
        const contactNotesTextarea = button.parentNode.querySelector('.contact-notes-quick');
        const contactNotes = contactNotesTextarea ? contactNotesTextarea.value.trim() : '';

        console.log('Contact notes from textarea:', contactNotes);

        // Prepare updates for both date and notes
        const updates = [];
        
        // Update Last Contact Date
        if (contactColIndex >= 0) {
          const columnLetter = indexToColumnLetter(contactColIndex);
          const sheetName = 'Sheet1';
          const cellRange = `${sheetName}!${columnLetter}${rowNumber}`;
          updates.push({
            range: cellRange,
            values: [[today]]
          });
          console.log('Adding Last Contact Date update:', cellRange, today);
        }

        // Update Contact Notes if column exists (save even if empty to allow clearing)
        if (contactNotesColIndex >= 0) {
          const notesColumnLetter = indexToColumnLetter(contactNotesColIndex);
          const sheetName = 'Sheet1';
          const notesCellRange = `${sheetName}!${notesColumnLetter}${rowNumber}`;
          updates.push({
            range: notesCellRange,
            values: [[contactNotes]]
          });
          console.log('Adding Contact Notes update:', notesCellRange, contactNotes);
        } else {
          console.warn('Contact Notes column not found in headers:', headers);
        }

        // Save both updates using batchUpdate
        if (updates.length > 0) {
          console.log('Sending batch update with', updates.length, 'updates:', updates);
          const response = await fetch(
            `https://sheets.googleapis.com/v4/spreadsheets/${sheetInfo.sheetId}/values:batchUpdate`,
            {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                valueInputOption: 'USER_ENTERED',
                data: updates
              })
            }
          );

          if (!response.ok) {
            const error = await response.json();
            console.error('Batch update error:', error);
            throw new Error(error.error?.message || 'Failed to save contact');
          }
          
          const result = await response.json();
          console.log('Batch update successful:', result);
        } else {
          console.warn('No updates to save');
        }

        // Update UI
        button.classList.add('contacted');
        button.textContent = '‚úì Contacted';
        
        // Add date display if it doesn't exist
        const existingDate = button.parentNode.querySelector('.contact-date');
        if (!existingDate) {
          const dateDiv = document.createElement('div');
          dateDiv.className = 'contact-date';
          dateDiv.textContent = `Last contact: ${today}`;
          button.parentNode.insertBefore(dateDiv, button.nextSibling);
        } else {
          existingDate.textContent = `Last contact: ${today}`;
        }

        // Update local data
        if (sheetData && sheetData.data && sheetData.data[originalRowIndex]) {
          const contactCol = headers.find(h => 
            h.toLowerCase() === 'last contact date' ||
            h.toLowerCase().includes('last contact') || 
            h.toLowerCase().includes('contact date') ||
            h.toLowerCase().includes('contacted')
          ) || contactColumn;
          sheetData.data[originalRowIndex][contactCol] = today;
          
          // Update contact notes in local data if column exists
          if (contactNotesColIndex >= 0 && contactNotes) {
            const contactNotesCol = headers[contactNotesColIndex];
            sheetData.data[originalRowIndex][contactNotesCol] = contactNotes;
          }
          
          // Update address map
          if (sheetData.addressMap && sheetData.addressMap.has(address)) {
            const rows = sheetData.addressMap.get(address);
            const row = rows.find(r => r.__originalIndex === originalRowIndex);
            if (row) {
              row[contactCol] = today;
              if (contactNotesColIndex >= 0 && contactNotes) {
                const contactNotesCol = headers[contactNotesColIndex];
                row[contactNotesCol] = contactNotes;
              }
            }
          }
        }

        // Update person entry styling
        const personEntry = button.closest('.person-entry');
        if (personEntry) {
          personEntry.classList.remove('no-contact');
          personEntry.classList.add('recent-contact');
        }

      } catch (error) {
        console.error('Error marking contact:', error);
        alert('Error saving contact: ' + error.message);
      }
    };


    // Chart instances
    let peopleContactChart = null;
    let householdsContactChart = null;
    let damageChart = null;
    let householdStatusChart = null;

    // Update Zone Progress Charts
    function updateZoneProgressCharts() {
      if (!sheetData || !sheetData.data || sheetData.data.length === 0) {
        const panel = document.getElementById('zoneProgressPanel');
        if (panel) panel.style.display = 'none';
        return;
      }

      // Show the panel
      const panel = document.getElementById('zoneProgressPanel');
      if (!panel) return;
      panel.style.display = 'block';

      const headers = sheetData.headers;
      const data = sheetData.data;

      // Find relevant columns
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));

      // 1. People Contacted Chart
      let peopleContacted = 0;
      let peopleNotContacted = 0;
      data.forEach(row => {
        const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
        if (hasContact) {
          peopleContacted++;
        } else {
          peopleNotContacted++;
        }
      });

      const peopleTotal = peopleContacted + peopleNotContacted;
      const peopleContactedPct = peopleTotal > 0 ? ((peopleContacted / peopleTotal) * 100).toFixed(1) : '0';
      const peopleNotContactedPct = peopleTotal > 0 ? ((peopleNotContacted / peopleTotal) * 100).toFixed(1) : '0';

      const peopleContactCtx = document.getElementById('peopleContactChart');
      if (peopleContactChart) peopleContactChart.destroy();
      if (peopleContactCtx) {
        peopleContactChart = new Chart(peopleContactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${peopleContactedPct}%)`, `Not Contacted (${peopleNotContactedPct}%)`],
            datasets: [{
              data: [peopleContacted, peopleNotContacted],
              backgroundColor: ['#4caf50', '#ff9800'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 2. Households Contacted Chart
      const households = new Set();
      const householdsContacted = new Set();
      const houseNumCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'House #' || lower === 'house #' || lower.includes('house #') || 
               lower.includes('house#') || lower === 'house number' || lower === 'house num' ||
               (lower === 'house' && !lower.includes('hold'));
      });
      const streetCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'Street' || lower === 'street' || (lower.includes('street') && !lower.includes('address'));
      });

      data.forEach(row => {
        const houseNum = houseNumCol ? (row[houseNumCol] || '').trim() : '';
        const street = streetCol ? (row[streetCol] || '').trim() : '';
        const address = houseNum && street ? `${houseNum} ${street}` : '';
        if (address) {
          households.add(address);
          const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
          if (hasContact) {
            householdsContacted.add(address);
          }
        }
      });

      const householdsContactedCount = householdsContacted.size;
      const householdsNotContactedCount = households.size - householdsContactedCount;
      const householdsTotal = householdsContactedCount + householdsNotContactedCount;
      const householdsContactedPct = householdsTotal > 0 ? ((householdsContactedCount / householdsTotal) * 100).toFixed(1) : '0';
      const householdsNotContactedPct = householdsTotal > 0 ? ((householdsNotContactedCount / householdsTotal) * 100).toFixed(1) : '0';

      const householdsContactCtx = document.getElementById('householdsContactChart');
      if (householdsContactChart) householdsContactChart.destroy();
      if (householdsContactCtx) {
        householdsContactChart = new Chart(householdsContactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${householdsContactedPct}%)`, `Not Contacted (${householdsNotContactedPct}%)`],
            datasets: [{
              data: [householdsContactedCount, householdsNotContactedCount],
              backgroundColor: ['#4caf50', '#ff9800'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 3. Damage Chart
      const damageCounts = {};
      let damageUnknown = 0;
      if (damageCol) {
        data.forEach(row => {
          const damage = row[damageCol] ? String(row[damageCol]).trim() : '';
          if (damage) {
            damageCounts[damage] = (damageCounts[damage] || 0) + 1;
          } else {
            damageUnknown++;
          }
        });
      } else {
        // If no damage column, all are unknown
        damageUnknown = data.length;
      }

      const damageLabels = Object.keys(damageCounts);
      const damageData = Object.values(damageCounts);
      const damageTotal = damageData.reduce((a, b) => a + b, 0) + damageUnknown;
      
      // Add Unknown if there are any
      if (damageUnknown > 0) {
        damageLabels.push('Unknown');
        damageData.push(damageUnknown);
      }
      
      // Calculate percentages for labels
      const damageLabelsWithPct = damageLabels.map((label, index) => {
        const value = damageData[index];
        const pct = damageTotal > 0 ? ((value / damageTotal) * 100).toFixed(1) : '0';
        return `${label} (${pct}%)`;
      });
      
      const damageColors = ['#f44336', '#ff9800', '#4caf50', '#2196f3', '#9c27b0', '#00bcd4', '#9e9e9e'];

      const damageCtx = document.getElementById('damageChart');
      if (damageChart) damageChart.destroy();
      if (damageCtx && (damageLabels.length > 0 || damageUnknown > 0)) {
        damageChart = new Chart(damageCtx, {
          type: 'pie',
          data: {
            labels: damageLabelsWithPct,
            datasets: [{
              data: damageData,
              backgroundColor: damageColors.slice(0, damageLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Remove percentage from label for tooltip (it's already in the label)
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 4. Household Status Chart
      const statusCounts = {};
      let statusUnknown = 0;
      if (statusCol) {
        data.forEach(row => {
          const status = row[statusCol] ? String(row[statusCol]).trim() : '';
          if (status) {
            statusCounts[status] = (statusCounts[status] || 0) + 1;
          } else {
            statusUnknown++;
          }
        });
      } else {
        // If no status column, all are unknown
        statusUnknown = data.length;
      }

      const statusLabels = Object.keys(statusCounts);
      const statusData = Object.values(statusCounts);
      const statusTotal = statusData.reduce((a, b) => a + b, 0) + statusUnknown;
      
      // Add Unknown if there are any
      if (statusUnknown > 0) {
        statusLabels.push('Unknown');
        statusData.push(statusUnknown);
      }
      
      // Calculate percentages for labels
      const statusLabelsWithPct = statusLabels.map((label, index) => {
        const value = statusData[index];
        const pct = statusTotal > 0 ? ((value / statusTotal) * 100).toFixed(1) : '0';
        return `${label} (${pct}%)`;
      });
      
      const statusColors = ['#2196f3', '#4caf50', '#ff9800', '#9c27b0', '#00bcd4', '#f44336', '#9e9e9e'];

      const statusCtx = document.getElementById('householdStatusChart');
      if (householdStatusChart) householdStatusChart.destroy();
      if (statusCtx && (statusLabels.length > 0 || statusUnknown > 0)) {
        householdStatusChart = new Chart(statusCtx, {
          type: 'pie',
          data: {
            labels: statusLabelsWithPct,
            datasets: [{
              data: statusData,
              backgroundColor: statusColors.slice(0, statusLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Remove percentage from label for tooltip (it's already in the label)
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
    }

    // Make displayAddressList available globally for back button
    window.displayAddressList = displayAddressList;
  </script>
</body>
</html>
