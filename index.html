<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Altagether NC Dashboard Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-kml@1.0.0/dist/leaflet-kml.js"></script>
  <style>
    :root {
      --mint: #8EBB8C;
      --sprout: #B5E593;
      --sunbeam: #FDF9CE;
      --honey: #E8C694;
      --clementine: #F95738;
      --plum: #6A057F;
      --sky: #B3E0F5;
      --river: #3A6EA5;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: var(--sky);
      color: #143039;
    }

    .shell {
      max-width: 1280px;
      margin: 0 auto;
      padding: 16px;
    }

    .nav {
      background: var(--river);
      color: #fff;
      padding: 12px 20px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 3px 10px rgba(0,0,0,0.1);
      margin-bottom: 16px;
    }

    .nav-title { font-weight: 600; }
    .nav-pill {
      background: var(--mint);
      color: #143039;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
    }

    .main { display: flex; gap: 16px; margin-bottom: 16px; align-items: stretch; }

    /* Column layout */
    .col-left { flex: 2; display: flex; flex-direction: column; gap: 16px; }
    .col-right { flex: 1; display: flex; flex-direction: column; gap: 16px; align-items: stretch; }

    .card {
      background: var(--sunbeam);
      border-radius: 10px;
      padding: 12px 14px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.06);
      border: 1px solid rgba(0,0,0,0.05);
    }

    .card-header {
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
    }

    .badge {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--sprout);
      color: #214025;
    }

    .map-card {
      min-height: 500px;
      height: 500px;
      background: var(--mint);
      position: relative;
      overflow: hidden;
    }

    .map-iframe {
      width: 100%;
      height: 100%;
      border: 0;
    }

    .map-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 500;
      color: rgba(0,0,0,0.5);
    }

    #zoneMap {
      width: 100%;
      height: calc(100% - 80px);
      border-radius: 0 0 8px 8px;
      z-index: 0;
    }

    .map-kml-input {
      margin: 0 8px 8px 8px;
      padding: 6px 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.85rem;
      width: calc(100% - 32px);
    }

    /* Spreadsheet panel now full-width below the map */
    .sheet-panel {
      background: #ffffff;
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.06);
    }

    .sheet-input-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .sheet-input {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 0.9rem;
    }


    .btn-load {
      padding: 6px 12px;
      background: var(--clementine);
      color: white;
      border: 0;
      border-radius: 999px;
      cursor: pointer;
    }

    .sheet-iframe {
      width: 100%;
      height: 480px; /* MUCH bigger now */
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 8px;
    }

    /* Address panel matches left column height (map 360px + gap 16px + link boxes) */
    .address-panel {
      height: 476px; /* Adjusted to align with bottom of link boxes */
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .address-panel-content {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
    }

    .address-filters {
      margin-bottom: 12px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .address-filters select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      font-size: 0.9rem;
      background: white;
      cursor: pointer;
    }

    .address-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .address-item {
      padding: 8px 10px;
      margin-bottom: 6px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .address-item:hover {
      background: rgba(255, 255, 255, 0.9);
      border-color: var(--river);
      transform: translateX(2px);
    }

    .address-item.active {
      background: var(--river);
      color: white;
      border-color: var(--river);
    }

    .address-details {
      display: none;
    }

    .address-details.active {
      display: block;
    }

    .address-details h3 {
      margin: 0 0 12px 0;
      font-size: 1.1rem;
      color: var(--river);
      border-bottom: 2px solid var(--river);
      padding-bottom: 6px;
    }

    .person-entry {
      background: rgba(255, 255, 255, 0.7);
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 6px;
      border-left: 3px solid var(--mint);
    }

    .person-name {
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--plum);
    }

    .person-info {
      font-size: 0.9rem;
      color: #143039;
      margin: 4px 0;
    }

    .person-info strong {
      color: var(--river);
    }

    .loading, .error, .empty {
      padding: 20px;
      text-align: center;
      color: rgba(0, 0, 0, 0.6);
    }

    .error {
      color: var(--clementine);
    }

    .btn-refresh {
      padding: 4px 10px;
      background: var(--mint);
      color: #143039;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-left: 8px;
      transition: transform 0.2s;
    }

    .btn-refresh:hover {
      transform: rotate(90deg);
    }

    .btn-refresh.active {
      background: var(--clementine);
      color: white;
    }

    .btn-back {
      padding: 6px 12px;
      background: var(--river);
      color: white;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-bottom: 12px;
    }

    .btn-signin {
      padding: 8px 16px;
      background: #4285f4;
      color: white;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin: 10px 0;
    }

    .btn-signin:hover {
      background: #357ae8;
    }

    .btn-save {
      padding: 6px 12px;
      background: var(--mint);
      color: #143039;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-top: 8px;
    }

    .btn-save:hover {
      background: var(--sprout);
    }

    .btn-save:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .signin-prompt {
      background: rgba(255, 255, 255, 0.8);
      padding: 16px;
      border-radius: 8px;
      text-align: center;
      margin: 10px 0;
      border: 2px dashed var(--river);
    }

    .signin-prompt p {
      margin: 0 0 12px 0;
      color: #143039;
      font-size: 0.9rem;
    }

    .editable-field {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--mint);
      border-radius: 4px;
      padding: 6px 8px;
      min-height: 20px;
      cursor: text;
      transition: all 0.2s;
    }

    .editable-field:focus {
      outline: none;
      border-color: var(--river);
      background: white;
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.2);
    }

    .editable-field:empty:before {
      content: "Click to add notes...";
      color: rgba(0, 0, 0, 0.4);
    }

    /* Subtle editable field for non-notes */
    .editable-inline {
      display: inline-block;
      background: rgba(255, 255, 255, 0.4);
      border: 1px dashed rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      padding: 2px 6px;
      min-width: 60px;
      cursor: text;
      transition: all 0.2s;
    }

    .editable-inline:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: var(--mint);
    }

    .editable-inline:focus {
      outline: none;
      background: white;
      border: 1px solid var(--river);
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .editable-inline:empty:before {
      content: "...";
      color: rgba(0, 0, 0, 0.3);
    }

    /* Dropdown for Damage and Household Status */
    .editable-dropdown {
      display: inline-block;
      background: rgba(255, 255, 255, 0.4);
      border: 1px dashed rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      padding: 2px 6px;
      min-width: 100px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: inherit;
      font-family: inherit;
      color: inherit;
    }

    .editable-dropdown:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: var(--mint);
    }

    .editable-dropdown:focus {
      outline: none;
      background: white;
      border: 1px solid var(--river);
      box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.15);
    }

    .save-status {
      font-size: 0.8rem;
      margin-top: 6px;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
    }

    .save-status.saving {
      background: var(--sunbeam);
      color: #143039;
    }

    .save-status.saved {
      background: var(--mint);
      color: #214025;
    }

    .save-status.error {
      background: var(--clementine);
      color: white;
    }

    .bottom-row {
      display: flex;
      gap: 16px;
    }

    .bottom-card { flex: 1; }
    .bottom-card:nth-child(1) { background: var(--honey); }
    .bottom-card:nth-child(2) { background: var(--sunbeam); }
    .bottom-card:nth-child(3) { background: var(--mint); }

    .link-list {
      margin: 6px 0 0;
      padding-left: 0;
      list-style: none;
      font-size: 0.9rem;
    }

    .link-list li { margin-bottom: 4px; }
    .link-list a { color: var(--river); text-decoration: none; }

    @media (max-width: 900px) {
      .main { flex-direction: column; }
      .bottom-row { flex-direction: column; }
    }
  </style>
</head>

<body>
  <div class="shell">

    <header class="nav">
      <div class="nav-title" id="navTitle">Altagether Zone Dashboard</div>
      <div class="nav-pill">Prototype</div>
    </header>

    <main class="main">
      <!-- LEFT COLUMN -->
      <section class="col-left">

        <!-- MAP -->
        <div class="card map-card">
          <div class="card-header">
            <span>Zone Map</span>
            <span class="badge">Interactive</span>
          </div>
          <input type="text" id="kmlUrlInput" class="map-kml-input" placeholder="Optional: Paste KML file URL for zone boundary" />
          <div id="zoneMap"></div>
        </div>

        <!-- BOTTOM LINKS -->
        <div class="bottom-row">
          <div class="card bottom-card">
            <div class="card-header"><span>Altagether Links</span></div>
            <ul class="link-list">
              <li><a href="#">NC Calendar</a></li>
              <li><a href="#">Community Agreements</a></li>
            </ul>
          </div>

          <div class="card bottom-card">
            <div class="card-header"><span>News Links</span></div>
            <ul class="link-list">
              <li><a href="#">Fire Recovery News</a></li>
              <li><a href="#">County Updates</a></li>
            </ul>
          </div>

          <div class="card bottom-card">
            <div class="card-header"><span>Support Pathways</span></div>
            <ul class="link-list">
              <li><a href="#">Disaster Case Mgmt</a></li>
              <li><a href="#">Legal Aid</a></li>
            </ul>
          </div>
        </div>
      </section>

      <!-- RIGHT COLUMN -->
      <section class="col-right">
        <div class="card address-panel">
          <div class="card-header">
            <span>Address Panel</span>
            <button class="btn-refresh" id="refreshAddressesBtn" title="Refresh addresses now">↻</button>
          </div>
          <div class="address-panel-content" id="addressPanelContent">
            <div class="empty">Load a spreadsheet to see addresses</div>
          </div>
          <div id="signinPrompt" style="display: none;" class="signin-prompt">
            <p><strong>Sign in to edit</strong><br>Click below to sign in with Google and enable editing</p>
            <button class="btn-signin" id="signInBtn">
              <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
              Sign in with Google
            </button>
          </div>
        </div>
      </section>
    </main>

    <!-- SPREADSHEET (full width below main content) -->
    <div class="card sheet-panel">
      <div class="card-header">
        <span>Your Zone Spreadsheet</span>
      </div>
      <div class="sheet-input-row">
        <input id="sheetUrlInput" class="sheet-input" placeholder="Paste Google Sheet /edit link" />
        <button class="btn-load" id="loadSheetBtn">Load</button>
      </div>
      <iframe id="sheetFrame" class="sheet-iframe"></iframe>
    </div>
  </div>

  <script>
    const input = document.getElementById("sheetUrlInput");
    const frame = document.getElementById("sheetFrame");
    const btn = document.getElementById("loadSheetBtn");
    const refreshBtn = document.getElementById("refreshAddressesBtn");
    const addressPanelContent = document.getElementById("addressPanelContent");
    const signInBtn = document.getElementById("signInBtn");
    const signinPrompt = document.getElementById("signinPrompt");
    const kmlUrlInput = document.getElementById("kmlUrlInput");

    let currentSheetUrl = '';
    let sheetData = [];
    let selectedAddress = null; // Track currently selected address
    let savedScrollPosition = 0; // Track scroll position for refresh
    let accessToken = null; // OAuth2 access token
    let currentSheetId = null; // Current sheet ID for writing
    let currentStreetFilter = 'all'; // Current street filter
    let currentDamageFilter = 'all'; // Current damage filter
    let currentStatusFilter = 'all'; // Current household status filter
    let zoneMap = null; // Leaflet map instance
    let addressMarkers = []; // Array of address markers
    let kmlLayer = null; // KML boundary layer

    // Load OAuth token from localStorage
    const savedToken = localStorage.getItem('googleOAuthToken');
    const savedTokenExpiry = localStorage.getItem('googleOAuthTokenExpiry');
    if (savedToken && savedTokenExpiry && Date.now() < parseInt(savedTokenExpiry)) {
      accessToken = savedToken;
      updateSignInUI();
    }

    // Initialize Google API
    function initGoogleAPI() {
      gapi.load('client', () => {
        gapi.client.init({
          apiKey: savedApiKey || '',
          discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
        }).then(() => {
          console.log('Google API initialized');
        });
      });
    }

    // Initialize on page load
    if (typeof gapi !== 'undefined') {
      initGoogleAPI();
    } else {
      window.addEventListener('load', () => {
        if (typeof gapi !== 'undefined') {
          initGoogleAPI();
        }
      });
    }

    // ============================================
    // CONFIGURATION: OAuth Client ID
    // ============================================
    // To enable editing, you need a Google OAuth Client ID:
    // 1. Go to https://console.cloud.google.com/apis/credentials
    // 2. Create OAuth 2.0 Client ID (Web application)
    // 3. Add your domain to authorized JavaScript origins
    // 4. Replace 'YOUR_CLIENT_ID' below with your actual Client ID
    // ============================================
    const OAUTH_CLIENT_ID = '633926045450-3214il5eg7emu5e0fp8am1g26jdfnoh7.apps.googleusercontent.com'; // Replace with your OAuth Client ID

    // OAuth2 Sign In
    async function signIn() {
      if (OAUTH_CLIENT_ID === 'YOUR_CLIENT_ID') {
        alert('OAuth Client ID not configured. Please set OAUTH_CLIENT_ID in the code.');
        return;
      }
      
      try {
        const tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: OAUTH_CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/spreadsheets',
          callback: (response) => {
            if (response.error) {
              console.error('Sign in error:', response.error);
              alert('Sign in failed. Please try again.');
              return;
            }
            accessToken = response.access_token;
            // Store token with expiry (tokens last 1 hour, store for 50 minutes)
            const expiry = Date.now() + (50 * 60 * 1000);
            localStorage.setItem('googleOAuthToken', accessToken);
            localStorage.setItem('googleOAuthTokenExpiry', expiry.toString());
            updateSignInUI();
            // Refresh current address if one is selected
            if (selectedAddress && currentSheetUrl) {
              loadAddressData(currentSheetUrl);
            }
          },
        });
        tokenClient.requestAccessToken({ prompt: 'consent' });
      } catch (error) {
        console.error('Sign in error:', error);
        alert('Error signing in. Please try again.');
      }
    }

    // Sign Out
    function signOut() {
      accessToken = null;
      localStorage.removeItem('googleOAuthToken');
      localStorage.removeItem('googleOAuthTokenExpiry');
      updateSignInUI();
      if (selectedAddress && currentSheetUrl) {
        loadAddressData(currentSheetUrl);
      }
    }

    // Update sign-in UI
    function updateSignInUI() {
      if (accessToken) {
        signinPrompt.style.display = 'none';
        // Could add a sign-out button here if needed
      } else {
        // Always show sign-in prompt when not signed in
        signinPrompt.style.display = 'block';
      }
    }

    // Sign in button handler
    signInBtn.addEventListener('click', signIn);

    // Extract sheet ID from any Google Sheets URL format
    function extractSheetId(sheetUrl) {
      // Handle published format: /spreadsheets/d/e/...
      const publishedMatch = sheetUrl.match(/\/spreadsheets\/d\/e\/([a-zA-Z0-9-_]+)/);
      if (publishedMatch) {
        return { sheetId: publishedMatch[1], isPublished: true };
      }
      
      // Handle standard format: /spreadsheets/d/...
      const standardMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
      if (!standardMatch) {
        return null;
      }
      
      return { sheetId: standardMatch[1], isPublished: false };
    }

    // Convert Google Sheets URL to CSV export URL
    function getCsvUrl(sheetUrl) {
      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        console.error('Could not parse Google Sheets URL:', sheetUrl);
        return null;
      }
      
      if (sheetInfo.isPublished) {
        // For published sheets, use /pub?output=csv
        const csvUrl = `https://docs.google.com/spreadsheets/d/e/${sheetInfo.sheetId}/pub?output=csv`;
        console.log('Converted published URL to CSV:', csvUrl);
        return csvUrl;
      }
      
      // For standard format, extract GID if present
      const gidMatch = sheetUrl.match(/[#&]gid=(\d+)/);
      const gid = gidMatch ? gidMatch[1] : '0';
      
      // Build CSV export URL
      const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetInfo.sheetId}/export?format=csv&gid=${gid}`;
      console.log('Converted standard URL to CSV:', csvUrl);
      return csvUrl;
    }

    // Fetch data using Google Sheets API v4 with OAuth token
    async function fetchViaOAuth(sheetId) {
      if (!accessToken) {
        throw new Error('Not signed in. Please sign in to view data.');
      }
      
      const apiUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/A1:ZZ1000`;
      
      const response = await fetch(apiUrl, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || `API Error: ${response.status}`);
      }
      
      const data = await response.json();
      return data.values || [];
    }

    // Parse CSV text to array of objects
    function parseCSV(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];

      // Parse header
      const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // Parse data rows
      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
        if (values.length === 0 || values.every(v => !v)) continue;
        
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        data.push(row);
      }
      
      return { headers, data };
    }

    // Convert API response (array of arrays) to object format
    function parseApiData(apiValues) {
      if (!apiValues || apiValues.length === 0) return { headers: [], data: [] };
      
      const headers = apiValues[0].map(h => h.trim());
      const data = [];
      
      for (let i = 1; i < apiValues.length; i++) {
        const row = {};
        headers.forEach((header, index) => {
          row[header] = apiValues[i][index] || '';
        });
        // Only add row if it has at least one non-empty value
        if (Object.values(row).some(v => v.trim())) {
          data.push(row);
        }
      }
      
      return { headers, data };
    }

    // Fetch and process spreadsheet data
    async function loadAddressData(sheetUrl) {
      // Save current scroll position before refreshing (if we're refreshing, not initial load)
      if (sheetData.addressMap) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      addressPanelContent.innerHTML = '<div class="loading">Loading addresses...</div>';

      // Require OAuth sign-in to read data
      if (!accessToken) {
        addressPanelContent.innerHTML = '<div class="error">Please sign in with Google to view data.</div>';
        // Show sign-in prompt
        signinPrompt.style.display = 'block';
        return;
      }

      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        addressPanelContent.innerHTML = '<div class="error">Invalid Google Sheets URL</div>';
        return;
      }
      
      try {
        let headers, data;
        
        // Use OAuth to fetch data
        console.log('Fetching data via OAuth...');
        try {
          const apiValues = await fetchViaOAuth(sheetInfo.sheetId);
          const parsed = parseApiData(apiValues);
          headers = parsed.headers;
          data = parsed.data;
          console.log('Successfully loaded via OAuth');
        } catch (oauthError) {
          console.error('OAuth fetch failed:', oauthError);
          throw new Error(`Error loading data: ${oauthError.message}. Make sure you're signed in and have access to this sheet.`);
        }
        
        // No fallback - OAuth is required
        if (!headers || !data) {
          // Fall back to CSV export (requires published sheet)
          const csvUrl = getCsvUrl(sheetUrl);
          if (!csvUrl) {
            throw new Error('Could not generate CSV URL');
          }

          // Try direct fetch first, then CORS proxy if needed
          let csvText;
          try {
            const response = await fetch(csvUrl);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            csvText = await response.text();
          } catch (error) {
            // If direct fetch fails, try CORS proxy
            console.log('Direct fetch failed, trying CORS proxy...', error);
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`;
            const proxyResponse = await fetch(proxyUrl);
            if (!proxyResponse.ok) {
              throw new Error(`Proxy fetch failed: ${proxyResponse.status}. Please sign in with Google.`);
            }
            csvText = await proxyResponse.text();
          }
          
          if (!csvText || csvText.trim().length === 0) {
            throw new Error('Spreadsheet appears to be empty or could not be accessed.');
          }
          
          const parsed = parseCSV(csvText);
          headers = parsed.headers;
          data = parsed.data;
        }
        
        if (data.length === 0) {
          addressPanelContent.innerHTML = '<div class="empty">No data found in spreadsheet</div>';
          return;
        }

        // Find address column (case-insensitive search)
        const addressCol = headers.find(h => 
          h.toLowerCase().includes('address') || 
          h.toLowerCase().includes('location')
        );

        if (!addressCol) {
          const availableCols = headers.join(', ');
          addressPanelContent.innerHTML = `<div class="error">No "Address" column found. Available columns: ${availableCols || 'none'}</div>`;
          return;
        }

        // Group data by address, storing original row index with each row
        const addressMap = new Map();
        data.forEach((row, rowIndex) => {
          const address = row[addressCol]?.trim();
          if (!address) return;
          
          if (!addressMap.has(address)) {
            addressMap.set(address, []);
          }
          // Store row with its original index
          addressMap.get(address).push({ ...row, __originalIndex: rowIndex });
        });

        // Store data globally
        sheetData = { headers, data, addressMap, addressCol };
        
        // Update header with Zone information
        const zoneCol = headers.find(h => h.toLowerCase().includes('zone'));
        let zoneValue = '';
        if (zoneCol && data.length > 0 && data[0][zoneCol]) {
          zoneValue = data[0][zoneCol].trim();
        }
        const navTitle = document.getElementById('navTitle');
        if (zoneValue) {
          navTitle.textContent = `${zoneValue} • Altagether Zone Dashboard`;
        } else {
          navTitle.textContent = 'Altagether Zone Dashboard';
        }
        
        // Store sheet ID for writing (sheetInfo already defined above)
        if (sheetInfo) {
          currentSheetId = sheetInfo.sheetId;
        }
        
        // Update sign-in UI
        updateSignInUI();
        
        // Reset filters when loading new data
        currentStreetFilter = 'all';
        currentDamageFilter = 'all';
        currentStatusFilter = 'all';
        
        // If an address was selected, restore that view; otherwise show list
        if (selectedAddress && addressMap.has(selectedAddress)) {
          displayAddressDetails(selectedAddress, true); // true = preserve scroll
        } else {
          displayAddressList(Array.from(addressMap.keys()).sort());
          // Restore scroll position for list view
          setTimeout(() => {
            addressPanelContent.scrollTop = savedScrollPosition;
          }, 0);
        }
        
        // Initialize or update map with addresses
        initializeMap();
        updateMapMarkers();
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        const errorMsg = error.message || 'Unknown error';
        
        let helpText = '';
        if (errorMsg.includes('permission') || errorMsg.includes('does not have permission') || errorMsg.includes('sign in')) {
          helpText = `<br><br><strong>Solution:</strong><br>
            1. Click "Sign in with Google" above<br>
            2. Grant permission to access Google Sheets<br>
            3. Make sure you have access to the sheet (it should be shared with you or set to "Anyone with the link can edit")<br>
            4. Refresh and try again`;
        } else {
          helpText = `<br><br>Tips:<br>• Sign in with Google to view and edit data<br>• Make sure the sheet is shared with you or set to "Anyone with the link can edit"<br>• Make sure the sheet has an "Address" column`;
        }
        
        addressPanelContent.innerHTML = `<div class="error">Error loading spreadsheet: ${errorMsg}${helpText}</div>`;
      }
    }

    // Extract street name from full address
    function extractStreet(address) {
      // Try to find Street column in headers
      const streetCol = sheetData.headers.find(h => h.toLowerCase().includes('street'));
      if (streetCol) {
        // Find the street value for this address
        const rows = sheetData.addressMap.get(address);
        if (rows && rows.length > 0 && rows[0][streetCol]) {
          return rows[0][streetCol].trim();
        }
      }
      // Fallback: try to extract from address string (e.g., "2054 MADISON AVE" -> "MADISON AVE")
      // This is a simple fallback - assumes format like "NUMBER STREET"
      const parts = address.split(/\s+/);
      if (parts.length > 1) {
        return parts.slice(1).join(' '); // Everything after the first part (house number)
      }
      return address;
    }

    // Get unique streets from all addresses
    function getUniqueStreets(addresses) {
      const streets = new Set();
      addresses.forEach(addr => {
        const street = extractStreet(addr);
        if (street) streets.add(street);
      });
      return Array.from(streets).sort();
    }

    // Get unique damage values from all addresses
    function getUniqueDamage(addresses) {
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      if (!damageCol) return [];
      
      const damages = new Set();
      // Check all data, not just filtered addresses
      sheetData.data.forEach(row => {
        if (row[damageCol] !== undefined && row[damageCol] !== null) {
          const damage = String(row[damageCol]).trim();
          if (damage) damages.add(damage);
        }
      });
      return Array.from(damages).sort();
    }

    // Get unique household status values from all addresses
    function getUniqueStatus(addresses) {
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (!statusCol) return [];
      
      const statuses = new Set();
      // Check all data, not just filtered addresses
      sheetData.data.forEach(row => {
        if (row[statusCol] !== undefined && row[statusCol] !== null) {
          const status = String(row[statusCol]).trim();
          if (status) statuses.add(status);
        }
      });
      
      // Always include default values (even if not in data yet)
      const defaultStatusValues = ['Selling', 'Staying', 'Renter/Moved'];
      defaultStatusValues.forEach(val => {
        // Check if this value exists (case-insensitive)
        const existing = Array.from(statuses).find(s => s.toLowerCase() === val.toLowerCase());
        if (existing && existing !== val) {
          // Replace with exact case from defaults
          statuses.delete(existing);
        }
        statuses.add(val);
      });
      
      return Array.from(statuses).sort();
    }

    // Get damage value for an address
    function getAddressDamage(address) {
      const damageCol = sheetData.headers.find(h => h.toLowerCase().includes('damage'));
      if (!damageCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][damageCol]?.trim() || null;
      }
      return null;
    }

    // Get household status value for an address
    function getAddressStatus(address) {
      const statusCol = sheetData.headers.find(h => h.toLowerCase().includes('household status'));
      if (!statusCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][statusCol]?.trim() || null;
      }
      return null;
    }

    // Display list of addresses
    function displayAddressList(addresses) {
      // Clear selected address when showing list
      selectedAddress = null;
      
      if (addresses.length === 0) {
        addressPanelContent.innerHTML = '<div class="empty">No addresses found</div>';
        return;
      }

      // Get unique values for all filters
      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      const statuses = getUniqueStatus(addresses);
      
      // Filter addresses by all selected filters
      const filteredAddresses = addresses.filter(addr => {
        // Street filter
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) {
          return false;
        }
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const addrDamage = getAddressDamage(addr);
          if (addrDamage !== currentDamageFilter) {
            return false;
          }
        }
        // Status filter
        if (currentStatusFilter !== 'all') {
          const addrStatus = getAddressStatus(addr);
          if (addrStatus !== currentStatusFilter) {
            return false;
          }
        }
        return true;
      });

      const html = `
        <div class="address-filters">
          <select id="streetFilter">
            <option value="all" ${currentStreetFilter === 'all' ? 'selected' : ''}>All Streets</option>
            ${streets.map(street => `
              <option value="${street.replace(/"/g, '&quot;')}" ${currentStreetFilter === street ? 'selected' : ''}>${street}</option>
            `).join('')}
          </select>
          <select id="damageFilter">
            <option value="all" ${currentDamageFilter === 'all' ? 'selected' : ''}>All Damage Status</option>
            ${damages.map(damage => `
              <option value="${damage.replace(/"/g, '&quot;')}" ${currentDamageFilter === damage ? 'selected' : ''}>${damage}</option>
            `).join('')}
          </select>
          <select id="statusFilter">
            <option value="all" ${currentStatusFilter === 'all' ? 'selected' : ''}>All Household Status</option>
            ${statuses.map(status => `
              <option value="${status.replace(/"/g, '&quot;')}" ${currentStatusFilter === status ? 'selected' : ''}>${status}</option>
            `).join('')}
          </select>
        </div>
        <ul class="address-list">
          ${filteredAddresses.map(addr => `
            <li class="address-item" data-address="${addr.replace(/"/g, '&quot;')}">
              ${addr}
            </li>
          `).join('')}
        </ul>
      `;
      
      addressPanelContent.innerHTML = html;
      
      // Add filter change handlers
      const streetFilter = document.getElementById('streetFilter');
      if (streetFilter) {
        streetFilter.addEventListener('change', (e) => {
          currentStreetFilter = e.target.value;
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
        });
      }
      
      const damageFilter = document.getElementById('damageFilter');
      if (damageFilter) {
        damageFilter.addEventListener('change', (e) => {
          currentDamageFilter = e.target.value;
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
        });
      }
      
      const statusFilter = document.getElementById('statusFilter');
      if (statusFilter) {
        statusFilter.addEventListener('change', (e) => {
          currentStatusFilter = e.target.value;
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers(); // Update map when filter changes
        });
      }
      
      // Update map markers when filters change
      updateMapMarkers();

      // Add click handlers
      document.querySelectorAll('.address-item').forEach(item => {
        item.addEventListener('click', () => {
          const address = item.getAttribute('data-address');
          displayAddressDetails(address);
          
          // Update active state
          document.querySelectorAll('.address-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
        });
      });
    }

    // Display details for a specific address
    function displayAddressDetails(address, preserveScroll = false) {
      if (!sheetData.addressMap || !sheetData.addressMap.has(address)) {
        return;
      }

      // Track selected address
      selectedAddress = address;
      
      // Save scroll position if we're refreshing
      if (preserveScroll) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      const rows = sheetData.addressMap.get(address);
      const { headers, addressCol } = sheetData;

      // Find relevant columns (exclude address column itself)
      const detailCols = headers.filter(h => 
        h !== addressCol && 
        h.toLowerCase() !== 'address' &&
        rows.some(row => row[h] && row[h].trim())
      );
      
      // Define which address-level fields to DISPLAY (others are hidden)
      // Note: "address" is excluded since it's shown as the heading
      const addressLevelDisplayFields = [
        'household size',
        'damage',
        'household status',
        'address notes'
      ];
      
      // Separate address-level and person-level columns
      const addressLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Explicitly exclude person-level notes and email address
        if (lower.includes('person note')) return false;
        if (lower.includes('email address')) return false;
        // Address-level: fields that are the same for all people at this address
        // But only include if they're in the display list
        const isSameForAll = rows.length > 0 && rows.every(r => (r[h] || '').trim() === (rows[0][h] || '').trim());
        const shouldDisplay = addressLevelDisplayFields.some(field => lower.includes(field));
        return isSameForAll && shouldDisplay;
      });
      
      // Fields to hide from person view
      const hiddenFromPersonView = [
        'house #',
        'street',
        'city',
        'state',
        'zip_code',
        'resident name',
        'zone',
        'nc name',
        'nc email',
        'damage',
        'household status',
        'household size'
      ];
      
      const personLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Skip hidden fields
        if (hiddenFromPersonView.some(field => lower.includes(field))) return false;
        // Person-level: Person Notes, Person Notes 2, Person Notes 3, or person-specific fields
        return lower.includes('person note') ||
               lower.includes('home phone') ||
               lower.includes('cell') ||
               lower.includes('email address') ||
               lower.includes('gender') ||
               lower.includes('age') ||
               (!addressLevelCols.includes(h) && detailCols.includes(h));
      });
      
      // Find Notes columns separately - always show them if signed in, even if empty
      const allNotesCols = headers.filter(h => 
        h !== addressCol &&
        h.toLowerCase().includes('note') &&
        accessToken // Only if signed in
      );
      
      // Add Notes columns to detailCols if not already there
      allNotesCols.forEach(col => {
        if (!detailCols.includes(col)) {
          detailCols.push(col);
        }
      });

      let html = `
        <button class="btn-back" onclick="displayAddressList(Array.from(sheetData.addressMap.keys()).sort())">← Back to List</button>
        <div class="address-details active">
          <h3>${address}</h3>
      `;

      // Collect unique values for dropdown fields from ALL data
      const damageValues = new Set();
      const statusValues = new Set();
      const damageCol = headers.find(h => h.toLowerCase().includes('damage'));
      const statusCol = headers.find(h => h.toLowerCase().includes('household status'));
      
      // Default status values (in case not all are found in data)
      const defaultStatusValues = ['Selling', 'Staying', 'Renter/Moved'];
      
      sheetData.data.forEach(row => {
        if (damageCol && row[damageCol] !== undefined && row[damageCol] !== null) {
          const value = String(row[damageCol]).trim();
          if (value) damageValues.add(value);
        }
        if (statusCol && row[statusCol] !== undefined && row[statusCol] !== null) {
          const value = String(row[statusCol]).trim();
          if (value) statusValues.add(value);
        }
      });
      
      // Add default status values if they weren't found (ensures all options are available)
      if (statusCol) {
        defaultStatusValues.forEach(val => statusValues.add(val));
      }
      
      console.log('Damage values found:', Array.from(damageValues));
      console.log('Status values found:', Array.from(statusValues));

      // Show address-level fields once at the top (always show, not just when signed in)
      if (addressLevelCols.length > 0) {
        html += '<div class="address-level-section" style="background: rgba(255,255,255,0.5); padding: 12px; border-radius: 8px; margin-bottom: 16px; border-left: 4px solid var(--river);">';
        html += '<div style="font-weight: 600; margin-bottom: 8px; color: var(--river);">Address Information</div>';
        
        addressLevelCols.forEach(col => {
          const firstRowValue = rows[0] ? (rows[0][col] || '') : '';
          const lower = col.toLowerCase();
          const isNotes = lower.includes('note');
          const isDamage = lower.includes('damage');
          const isStatus = lower.includes('household status');
          const isEditable = accessToken; // All fields editable when signed in
          
          if (isEditable) {
            if (isNotes) {
              // Notes: big white box
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <div class="editable-field" contenteditable="true" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-address-level="true"
                     data-column="${col}"
                     data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue}</div>
              </div>`;
            } else if (isDamage || isStatus) {
              // Damage/Status: dropdown
              const options = isDamage ? Array.from(damageValues).sort() : Array.from(statusValues).sort();
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <select class="editable-dropdown" 
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">
                  <option value="">(not set)</option>
                  ${options.map(opt => `<option value="${opt.replace(/"/g, '&quot;')}" ${opt === firstRowValue ? 'selected' : ''}>${opt}</option>`).join('')}
                </select>
              </div>`;
            } else {
              // Other fields: subtle editable
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-address-level="true"
                      data-column="${col}"
                      data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue || ''}</span>
              </div>`;
            }
          } else {
            // Not signed in: display only
            html += `<div class="person-info"><strong>${col}:</strong> ${firstRowValue || '(not set)'}</div>`;
          }
        });
        
        html += '</div>';
      }

      // Show person-level fields for each person
      rows.forEach((row, index) => {
        // Get the original row index that was stored when grouping
        const originalRowIndex = row.__originalIndex !== undefined ? row.__originalIndex : -1;
        
        html += '<div class="person-entry">';
        
        // Try to find name column - show Resident Name as the person's name
        const nameCol = headers.find(h => 
          h.toLowerCase().includes('resident name') || 
          (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name'))
        );
        
        if (nameCol && row[nameCol]) {
          html += `<div class="person-name">${row[nameCol]}</div>`;
        } else if (rows.length > 1) {
          html += `<div class="person-name">Person ${index + 1}</div>`;
        }

        // Display person-level fields (show even if empty, like Notes)
        personLevelCols.forEach(col => {
          const isNotes = col.toLowerCase().includes('note');
          const isEditable = accessToken; // All fields editable when signed in
          
          // Skip Resident Name since we already show it as the person's name
          if (col.toLowerCase().includes('resident name')) return;
          
          if (isEditable) {
            if (isNotes) {
              // Notes: big white box
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <div class="editable-field" contenteditable="true" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-original-row-index="${originalRowIndex}" 
                     data-column="${col}"
                     data-address-level="false"
                     data-original-value="${(row[col] || '').replace(/"/g, '&quot;')}">${row[col] || ''}</div>
              </div>`;
            } else {
              // Other fields: subtle editable
              const value = row[col] || '';
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-original-row-index="${originalRowIndex}" 
                      data-column="${col}"
                      data-address-level="false"
                      data-original-value="${value.replace(/"/g, '&quot;')}">${value || ''}</span>
              </div>`;
            }
          } else {
            // Show all person-level fields, even if empty
            const value = row[col] || '';
            html += `<div class="person-info"><strong>${col}:</strong> ${value || '(not set)'}</div>`;
          }
        });
        
        // Display other non-notes fields that aren't address-level (but exclude hidden fields)
        detailCols.forEach(col => {
          const lower = col.toLowerCase();
          const isHidden = hiddenFromPersonView.some(field => lower.includes(field));
          if (!addressLevelCols.includes(col) && !personLevelCols.includes(col) && 
              !col.toLowerCase().includes('note') && !isHidden) {
            if (row[col] && row[col].trim()) {
              html += `<div class="person-info"><strong>${col}:</strong> ${row[col]}</div>`;
            }
          }
        });

        html += '</div>';
      });

      // Add save button if signed in and there are editable fields
      if (accessToken) {
        html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 2px solid var(--river);">
            <button class="btn-save" id="saveChangesBtn">Save Changes</button>
            <span class="save-status" id="saveStatus"></span>
          </div>
        `;
      }

      html += '</div>';
      addressPanelContent.innerHTML = html;
      
      // Add save button handler
      const saveBtn = document.getElementById('saveChangesBtn');
      if (saveBtn) {
        saveBtn.addEventListener('click', saveChanges);
      }
      
      // Add change handlers for dropdowns
      document.querySelectorAll('.editable-dropdown').forEach(dropdown => {
        dropdown.addEventListener('change', () => {
          // Mark as changed for save
          dropdown.setAttribute('data-changed', 'true');
        });
      });
      
      // Restore scroll position if refreshing, otherwise scroll to top
      setTimeout(() => {
        if (preserveScroll) {
          addressPanelContent.scrollTop = savedScrollPosition;
        } else {
          addressPanelContent.scrollTop = 0; // Start at top for new address
        }
      }, 0);
    }

    // Load sheet button handler
    btn.addEventListener("click", () => {
      let url = input.value.trim();
      if (!url) return;

      if (url.includes("/view")) {
        url = url.replace("/view", "/edit");
      }

      currentSheetUrl = url;
      frame.src = url;
      
      // Also load the address data
      loadAddressData(url);
    });

    // Refresh button handler
    refreshBtn.addEventListener("click", () => {
      if (currentSheetUrl) {
        loadAddressData(currentSheetUrl);
      }
    });

    // Save changes to spreadsheet
    async function saveChanges() {
      if (!accessToken || !currentSheetId) {
        alert('Please sign in to save changes.');
        return;
      }

      const saveBtn = document.getElementById('saveChangesBtn');
      const saveStatus = document.getElementById('saveStatus');
      // Get all editable elements: Notes fields, inline fields, and dropdowns
      const editableFields = document.querySelectorAll('.editable-field[contenteditable="true"], .editable-inline[contenteditable="true"]');
      const editableDropdowns = document.querySelectorAll('.editable-dropdown');
      
      if (editableFields.length === 0 && editableDropdowns.length === 0) {
        return;
      }

      saveBtn.disabled = true;
      saveStatus.textContent = 'Saving...';
      saveStatus.className = 'save-status saving';

      try {
        // Collect all changes
        const updates = [];
        editableFields.forEach(field => {
          const newValue = field.textContent.trim();
          const originalValue = field.getAttribute('data-original-value');
          const column = field.getAttribute('data-column');
          const isAddressLevel = field.getAttribute('data-address-level') === 'true';
          const address = field.getAttribute('data-address');
          const originalRowIndex = parseInt(field.getAttribute('data-original-row-index'));

          if (newValue !== originalValue) {
            // Find the column index
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex === -1) return;

            // Convert column index to letter (A, B, C, etc.)
            // Handle columns beyond Z (AA, AB, etc.)
            function indexToColumnLetter(index) {
              let result = '';
              while (index >= 0) {
                result = String.fromCharCode(65 + (index % 26)) + result;
                index = Math.floor(index / 26) - 1;
              }
              return result;
            }
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            } else {
              // Person-level: update only this specific row
              if (originalRowIndex !== -1) {
                const rowNumber = originalRowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                const range = `${colLetter}${rowNumber}`;
                updates.push({
                  range: `Sheet1!${range}`,
                  values: [[newValue]]
                });
              }
            }
          }
        });
        
        // Handle dropdown fields
        editableDropdowns.forEach(dropdown => {
          const newValue = dropdown.value.trim();
          const originalValue = dropdown.getAttribute('data-original-value');
          const column = dropdown.getAttribute('data-column');
          const isAddressLevel = dropdown.getAttribute('data-address-level') === 'true';
          const address = dropdown.getAttribute('data-address');

          if (newValue !== originalValue) {
            // Find the column index
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex === -1) return;

            // Convert column index to letter
            function indexToColumnLetter(index) {
              let result = '';
              while (index >= 0) {
                result = String.fromCharCode(65 + (index % 26)) + result;
                index = Math.floor(index / 26) - 1;
              }
              return result;
            }
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2;
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            }
          }
        });

        if (updates.length === 0) {
          saveStatus.textContent = 'No changes to save';
          saveStatus.className = 'save-status';
          saveBtn.disabled = false;
          return;
        }

        // Use Google Sheets API to update
        const response = await fetch(
          `https://sheets.googleapis.com/v4/spreadsheets/${currentSheetId}/values:batchUpdate`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              valueInputOption: 'USER_ENTERED',
              data: updates
            })
          }
        );

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'Failed to save');
        }

        // Update original values
        editableFields.forEach(field => {
          field.setAttribute('data-original-value', field.textContent.trim());
        });
        editableDropdowns.forEach(dropdown => {
          dropdown.setAttribute('data-original-value', dropdown.value.trim());
        });

        saveStatus.textContent = 'Saved!';
        saveStatus.className = 'save-status saved';
        
        // Refresh data after a short delay
        setTimeout(() => {
          if (currentSheetUrl) {
            loadAddressData(currentSheetUrl);
          }
        }, 1000);

      } catch (error) {
        console.error('Save error:', error);
        saveStatus.textContent = `Error: ${error.message}`;
        saveStatus.className = 'save-status error';
      } finally {
        saveBtn.disabled = false;
      }
    }

    // Initialize Leaflet map
    function initializeMap() {
      const mapDiv = document.getElementById('zoneMap');
      if (!mapDiv) {
        console.error('Map div not found');
        return;
      }
      
      if (!zoneMap) {
        try {
          // Default center (Altadena, CA - adjust as needed)
          zoneMap = L.map('zoneMap').setView([34.19, -118.15], 13);
          
          // Add OpenStreetMap tiles
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(zoneMap);
          
          console.log('Map initialized');
        } catch (error) {
          console.error('Error initializing map:', error);
        }
      }
      
      // Load KML if URL is provided
      const kmlUrl = kmlUrlInput && kmlUrlInput.value ? kmlUrlInput.value.trim() : '';
      if (kmlUrl) {
        loadKMLBoundary(kmlUrl);
      }
    }

    // Convert Google Drive sharing URL to direct download URL
    function convertGoogleDriveUrl(url) {
      // Extract file ID from Google Drive sharing URL
      // Format: https://drive.google.com/file/d/FILE_ID/view?usp=sharing
      // Or: https://drive.google.com/open?id=FILE_ID
      let fileId = null;
      
      // Try pattern 1: /file/d/FILE_ID/
      const match1 = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
      if (match1 && match1[1]) {
        fileId = match1[1];
      } else {
        // Try pattern 2: ?id=FILE_ID
        const match2 = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
        if (match2 && match2[1]) {
          fileId = match2[1];
        }
      }
      
      if (fileId) {
        // Try alternative Google Drive export URL format
        // The confirm=t parameter sometimes helps bypass virus scan
        return `https://drive.google.com/uc?export=download&id=${fileId}&confirm=t`;
      }
      
      // If it's already a direct download URL or other format, return as-is
      return url;
    }

    // Load KML boundary
    async function loadKMLBoundary(kmlUrl) {
      try {
        // Remove existing KML layer
        if (kmlLayer) {
          zoneMap.removeLayer(kmlLayer);
        }
        
        // Convert Google Drive URL if needed
        const directUrl = convertGoogleDriveUrl(kmlUrl);
        console.log('Loading KML from:', directUrl);
        
        // Fetch KML file with CORS proxy fallback
        let response;
        let kmlText;
        try {
          // Try direct fetch first
          response = await fetch(directUrl);
          if (!response.ok) {
            throw new Error(`Failed to fetch: ${response.status}`);
          }
          kmlText = await response.text();
        } catch (error) {
          // If direct fetch fails (CORS issue), try CORS proxy
          console.log('Direct fetch failed, trying CORS proxy...', error);
          const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(directUrl)}`;
          response = await fetch(proxyUrl);
          if (!response.ok) {
            throw new Error(`Failed to fetch KML via proxy: ${response.status} ${response.statusText}. Make sure the file is shared publicly.`);
          }
          kmlText = await response.text();
        }
        
        // Parse KML to GeoJSON
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlText, 'text/xml');
        
        // Check for parsing errors
        const parseError = kml.querySelector('parsererror');
        if (parseError) {
          throw new Error('KML parsing error: ' + parseError.textContent);
        }
        
        // Convert KML to GeoJSON (toGeoJSON is from @mapbox/togeojson)
        let geojson;
        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
          geojson = toGeoJSON.kml(kml);
        } else {
          throw new Error('toGeoJSON library not loaded');
        }
        
        // Add to map
        kmlLayer = L.geoJSON(geojson, {
          style: {
            color: '#214025',
            weight: 3,
            opacity: 0.8,
            fillColor: '#214025',
            fillOpacity: 0.1
          }
        }).addTo(zoneMap);
        
        // Fit map to boundary
        if (kmlLayer.getBounds && kmlLayer.getBounds().isValid()) {
          zoneMap.fitBounds(kmlLayer.getBounds(), { padding: [20, 20] });
        }
      } catch (error) {
        console.error('Error loading KML:', error);
        alert('Error loading KML file: ' + error.message);
      }
    }

    // Update map markers based on filtered addresses
    function updateMapMarkers() {
      if (!sheetData || !sheetData.addressMap) {
        console.log('No sheet data available for map');
        return;
      }
      
      // Make sure map is initialized
      if (!zoneMap) {
        console.log('Map not initialized, initializing now...');
        initializeMap();
        if (!zoneMap) {
          console.error('Failed to initialize map');
          return;
        }
      }
      
      // Clear existing markers
      addressMarkers.forEach(marker => zoneMap.removeLayer(marker));
      addressMarkers = [];
      
      // Get filtered addresses (same logic as displayAddressList)
      const addresses = Array.from(sheetData.addressMap.keys());
      const filteredAddresses = addresses.filter(address => {
        // Street filter
        if (currentStreetFilter !== 'all') {
          const street = extractStreet(address);
          if (street !== currentStreetFilter) return false;
        }
        
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const damage = getAddressDamage(address);
          if (damage !== currentDamageFilter) return false;
        }
        
        // Status filter
        if (currentStatusFilter !== 'all') {
          const status = getAddressStatus(address);
          if (status !== currentStatusFilter) return false;
        }
        
        return true;
      });
      
      // Check for lat/lon columns
      const latCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lat') || lower === 'latitude';
      });
      const lonCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lon') || lower.includes('lng') || lower === 'longitude';
      });
      
      console.log('Looking for coordinates - Lat column:', latCol, 'Lon column:', lonCol);
      console.log('Available headers:', sheetData.headers);
      
      if (!latCol || !lonCol) {
        console.log('Lat/Lon columns not found. Available columns:', sheetData.headers);
        return;
      }
      
      // Add markers for filtered addresses
      const bounds = [];
      let markerCount = 0;
      filteredAddresses.forEach(address => {
        const rows = sheetData.addressMap.get(address);
        if (!rows || rows.length === 0) return;
        
        const firstRow = rows[0];
        let lat, lon;
        
        // Try to get coordinates from lat/lon columns
        const latVal = firstRow[latCol];
        const lonVal = firstRow[lonCol];
        
        if (latVal !== undefined && latVal !== null && latVal !== '' && 
            lonVal !== undefined && lonVal !== null && lonVal !== '') {
          lat = parseFloat(String(latVal).trim());
          lon = parseFloat(String(lonVal).trim());
          if (isNaN(lat) || isNaN(lon)) {
            console.log(`Invalid coordinates for ${address}: lat=${latVal}, lon=${lonVal}`);
            return;
          }
        } else {
          return; // Skip if no coordinates
        }
        
        // Create marker
        try {
          const marker = L.marker([lat, lon]).addTo(zoneMap);
          
          // Add popup with address
          marker.bindPopup(`<strong>${address}</strong>`);
          
          // Click handler to show address details
          marker.on('click', () => {
            displayAddressDetails(address);
          });
          
          addressMarkers.push(marker);
          bounds.push([lat, lon]);
          markerCount++;
        } catch (error) {
          console.error(`Error creating marker for ${address}:`, error);
        }
      });
      
      console.log(`Added ${markerCount} markers to map`);
      
      if (markerCount === 0) {
        console.log('No markers created - check that Latitude and Longitude columns have data');
        return;
      }
      
      // Fit map to show all markers (if we have markers and no KML boundary)
      if (bounds.length > 0 && !kmlLayer) {
        zoneMap.fitBounds(bounds, { padding: [20, 20] });
      }
    }

    // KML URL input handler
    if (kmlUrlInput) {
      kmlUrlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          if (zoneMap) {
            loadKMLBoundary(kmlUrlInput.value.trim());
          }
        }
      });
    }

    // Make displayAddressList available globally for back button
    window.displayAddressList = displayAddressList;
  </script>
</body>
</html>
